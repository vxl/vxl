#! /bin/sh
exec perl -w -x $0 ${1+"$@"}
#!perl
#line 5

# Purpose: list all files in the vxl source tree that have tab characters
# (and that shouldn't have them because vxl C++ source files shouldn't).
# There are a few other "inconsistencies" which are also mentioned, some of
# these optionally, unless "-f" is specified on the command line.

# If "-e" is given on the command line, output lines are in this format:
# <filename>:<line_number>: # <message>
# so the result can be processed by emacs in compile-mode.  Right now
# the line number is almost always 1, which at least allows you to jump to the
# file, if not the correct line number.
# For use with vim, use "-v" on the command line; then, the output format is
# vim +<line_number> <filename> # <message>
#
# ;; sample compile command for emacs
# (setq compile-command
#  "find $VXLROOT -type f \( -name \*.cxx -o -name \*.txx -o -name \*.h \) -exec $VXLROOT/core/bin/check_syntax -e -f {} \\;" )
# ESC-x compile

undef $/;
$full = "";
$emacs = "";
$vim = "";

while (defined($ARGV[0]) && $ARGV[0] =~ m!^-!)
{
  $_ = shift(@ARGV);
  if (m/^-f$/) { $full = 1; }
  elsif (m/^-e$/) { $emacs = 1; }
  elsif (m/^-v$/) { $vim = 1; }
  else { printf STDERR "Unrecognised command line option $_ ignored\n"; }
}

if (defined($ARGV[0]))
{
  @FILES = @ARGV;
}
else
{
  $VXLROOT = $ENV{VXLROOT};
  unless (defined($VXLROOT))
  {
    print STDERR "VXLROOT is not defined, and no command line arguments were given\n";
    exit 0;
  }
  $FILES = `find $VXLROOT/config $VXLROOT/vcl $VXLROOT/v3p $VXLROOT/core $VXLROOT/contrib -type f \\\( -name \\\*.cxx -o -name \\\*.txx -o -name \\\*.cc -o -name \\\*.cpp -o -name \\\*.c -o -name \\\*.h \\\) -print|grep -v v3p/xerces-c-src1_4_0/|grep -v v3p/dcmtk/`;
  @FILES = split(' ', $FILES);
}

# In what follows, $f is the name of the file, $file is the file content, and $file_s is a comment-stripped version of $file.
foreach $f (@FILES)
{
  if (-d $f)
  {
    print STDERR "File $f is actually a directory\n";
    next;
  }
  unless (open(FILE, $f))
  {
    print STDERR "File $f does not exist or cannot be opened for reading\n";
    next;
  }
  $file=<FILE>;
  close FILE;
  next unless (defined($file));
  $file =~ s!\$\{FILESTEM\}!classtemplate_emacs!g;
  $file =~ s!libname/classname!config/classtemplate!g;
  $file =~ s!\@\(eval \(file-name-nondirectory \(file-name-directory-noslash dirname\)\)\)/\@\(eval dirbase\)!config!g;
  $printed = $full;

  $cpp_file = ($f !~ m!\.c$! &&
               $f !~ m!\bintroduction_doxy\.txt$! &&
               $f !~ m!_mocced\.cxx$! &&
               $f !~ m!\bv3p/(netlib|[jm]peg2?|tiff|png|zlib|Qv)/! &&
               $f !~ m!vil1?/file_formats/vil1?_viff(header|_support)! &&
               $f !~ m!\bvgui/internals/trackball! &&
               $f !~ m!\bcore/vgl/internals/gpc\.h$! &&
               $f !~ m!\bcore/vidl/vidl_mpegcodec_helper\.cxx$! &&
               $f !~ m!\bcore/vidl_vil1/vidl_vil1_mpegcodec_helper\.cxx$! &&
               $f !~ m!/oufgl/(pxc200|bt848(-addons)?)\.h$! &&
               $f !~ m!\bgel/vgel/kl/.*\.h$! &&
               $f !~ m!\bvcl(/[^/]+)?/vcl_(c|[siof]+stream|io|strstream|streambuf)! &&
               $f !~ m!\bvcl/emulation/!
              );
  study $file;

# 1. abnormal characters (tabs, ascii < 32, etc.)
  $file =~ s!\347!c!g; # treat ç as normal character
  $file =~ s!(\"http:)//!$1\\\\!g; # do not treat "http://" as a comment delimiter
  &msg(1, "contains tabs")
    if ($file =~ m!\t! && $file !~ m!\basm\s*\(\"\t!);
  &msg(1, "contains carriage returns (ascii 13)")
    if ($file =~ m!\r! && $f !~ m!\.ds[pw]$!);
  &msg(1, "contains non-standard ascii characters")
    if ($file =~ m![\000-\010\013\014\016-\037\177-\277\320\327\336\360\367\376]!);

# 2. spaces (more than 1) at end of line
  $has_end_spaces = ($file =~ m!  +\n!);

# 3. Lines longer than 132 characters, continuation ostream, single-char strings
  if ($file =~ m!.{133,}! && $f !~ m!\.dsp$!)
  {
    $tmp=$file; $tmp =~ s!.{133,}[^\000]*!!; $tmp =~ s![^\n]*!!g; $tmp=length($tmp)+1;
    &msg($tmp, "has lines of more than 132 characters");
  }
  &msg(1, "has vcl_endl following a string: consider replacing by \\n\"")
    if ($printed && $file =~ m!\"\s*\<\<\s*vcl_endl\b!);
  &msg(1, "consider joining consecutive \"\<\<\" output lines for $2")
    if ($printed && $file =~ m![{;:](\s*//.*\n)?\s*([a-zA-Z]\S*)\s*\<\<[^;]+\;\s*\2\s*\<\<!);
  &msg(1, "consider joining consecutive strings in output for $1")
    if ($printed && $file =~ m!(\S+)\s*\<\<[^;]*(..)\"\s*\<\<\s*\"! && $2 ne "\\n" && $2 ne " -");
  &msg(1, "consider replacing \"$2\" by \'$2\' in output for $1")
    if ($printed && $file =~ m!(\S+)\s*\<\<[^;]+\"([^\\]|\\.)\"!);
  &msg(1, "consider removing space before \\n")
    if ($printed && $file =~ m!(\s|\\t)\\n\b!);

# 4. Consecutive comment blocks, separated by blank lines
  if ($file =~ m!\n\s*//:.*\n( *// .*\n)*\s*\n\s*// !)
  {
    $tmp=$file; $tmp =~ s!\n\s*//:.*\n( *// .*\n)*\s*\n\s*[^\000]*!!; $tmp =~ s![^\n]*!!g; $tmp=length($tmp)+2;
    &msg($tmp, "contains comment blocks separated by a blank line; consider joining");
  }

# 5. Quick consistency check of Doxygen structured comments
  &msg(1, "doxygen comments will not be shown without \\file")
    if ($file =~ m!\n\s*//:! && $file !~ m!\n\s*//:(\s*\n\s*//)?\s*\\file\b! &&
                                $file !~ m!^\s*//:(\s*\n\s*//)?\s*\\file\b!);
  &msg(1, "doxygen \\file better not have an argument, so remove \"$1\"")
    if ($file =~ m!//\s*\\file[ \t]+(\S.*)!);
  if ($file =~ m!\n\s*//(:|\s*\\brief\b)[ \t]*(.{40,})\n *// *([a-z].*)!)
  {
    $first=$2; $second=$3;
    unless ($first =~ m/[.?!]$/ || $second =~ m!^v[bcginpsu]l_!)
    {
      $tmp=$file; $tmp =~ s!\n\s*//(:|\s*\\brief\b)[ \t]*(.{40,})\n *//[^\000]*!!; $tmp =~ s![^\n]*!!g; $tmp=length($tmp)+2;
      &msg($tmp, "brief comment possibly continued on next line");
    }
  }
  elsif ($file =~ m!\n\s*//(:|\s*\\brief\b)(.{40,}\b(and|if|but|since|that|,))\s*\n *// *(.+)!i)
  {
    $tmp=$file; $tmp =~ s!\n\s*//(:|\s*\\brief\b)(.{40,}\b(and|if|but|since|that|,))\s*\n *// *(.+)[^\000]*!!i; $tmp =~ s![^\n]*!!g; $tmp=length($tmp)+2;
    &msg($tmp, "brief comment possibly continued on next line");
  }

# 6. Unnecessary #include files and missing #include files.
#   Unnecessary includes are in principle anything which is not
#   used or directly referred to in the current file.
#   Missing includes is currently only vcl_cassert.h and vcl_iostream.h
  $fl = $file; $fl =~ s!//.*!!g;
  $includes = "\004\n$fl\003";
  $includes =~ s!\n\s*\#\s*include\s\<([^>]+)\>.*!\003$1\004!g;
  $includes =~ s!^[^\003]*\003!\003!; $includes =~ s!\004[^\004]*$!\004!;
  $includes =~ s!\004[^\003]*\003!\n!g; $includes =~ s![\004\003]!!g;
  @includes = sort(split('\n', $includes));
  $jj = ""; $found_cassert = ""; $found_iostream = "";
  foreach $j (@includes)
  {
    next if ($j eq "");
    $found_cassert = 1 if ($j eq "vcl_cassert.h" || $j eq "assert.h");
    $found_iostream = 1 if ($j =~ m!^vcl_((i|o|io|f)stream|iosfwd|streambuf)\.h! || $j eq "vsl/vsl_binary_io.h");
    &msg(1, "invalid #include <$j>")
      unless ($j =~ m!\.(h|H|hxx|hpp|txx)$! || $f =~ m!/vcl/|/cmake/config/! || $j eq "std/complext.cc");
    next unless ($j =~ m!\.h$!i);
    next if ($f =~ m!(v.l)/tests/(\1_)?test_(includes?|all)\.cxx$! && $j =~ m!^$1(/algo)?/$1_!);
    next if ($f =~ m!vnl/algo/Templates/vcl_vector\+vnl_amoeba_SimplexCorner-\.cxx$! && $j eq "vnl/algo/vnl_amoeba.h");
    next if ($f =~ m!vnl/vnl_math\.cxx$! && $j eq "math.h");
    next if ($f =~ m!vpl/vpl\.cxx$! && $j eq "vpl/os_unix/vpl.cxx");
    next if ($f =~ m!vbl_test_smart_ptr\.cxx$! && $j eq "vbl/vbl_smart_ptr.h");
    next if ($f =~ m!vpdfl/vpdfl_all\.h$!);
    next if ($f =~ m!pdf1d/pdf1d_all\.h$!);
    next if ($f =~ m!doc/vxl_doc_rules\.h!);
    &msg(1, "has multiple occurrence of \#include <$j>")
      if ($j eq $jj &&
          $f !~ m!/vcl/vcl_(cstddef|climits|new|sys/time)\.h$! &&
          $f !~ m!/vcl/tests/test_stlfwd\.cxx$! &&
          $f !~ m!/cmake/config/vxl_platform_tests\.cxx$! &&
          $f !~ m!/v.l/io/tests/golden_test_v.l_io\.cxx$! &&
         "$f-$j" !~ m!\bv3p/netlib/triangle\.c\-math\.h$! &&
         "$f-$j" !~ m!\bv3p/png/tests/pngtest\.c\-time\.h$! &&
          $j !~ m!^(stdlib|varargs|sys/types|stdio|windows|GL/glu?t?)\.h$!);
    $jj = $j; $i = $j;
    next unless ($i =~ s!^(v[bginpsu]l|vil1|vgui|vidl|vidl_vil1|vtol|vsol|vdgl|vipl/vipl_with_[a-z_]+|vipl|vepl2?|mbl|pdf1d|vpdfl|mil|mil3d|vimt|vimt3d|gevd|bsol|btol|bugl|bvnl|bvgl|bgui|bdgl|rrel|rsdl|rgrl)/(file_formats/|algo/|io/|internals/|filter/|section/|vrml/|impl/(X|glut|gtk|mfc)/|)(.*)\.h!$4! || $i =~ s!^(v[cx]l_[a-z]+)\.h$!$1!);
    next if ($f . " " . $j =~ m!(.*)\.h \1_sptr\.h!);
    next if ($j eq "vcl_compiler.h" || $j eq "vcl_new.h");
    next if ($j eq "vcl_cstdio.h" && $f =~ m!/StdAfx\.h$!);
    next if ($j eq "vcl_cmath.h" && $f =~ m!\bvcl/(vcl_cfloat|win32-vc60/vcl_complex)\.h$!);
    next if ($j eq "vcl_cmath.h" && $f =~ m!\bvnl/algo/vnl_generalized_eigensystem\.cxx$!);
    next if ($j eq "vcl_cstdlib.h" && $f =~ m!\bvcl/emulation/vcl_algobase\.h$!);
    next if ($j eq "vcl_ctime.h" && $f =~ m!\bvcl/emulation/vcl_alloc\.h$!);
    next if ($j eq "vcl_algorithm.h" && $f =~ m!\bvcl/gcc-295/vcl_deque\.txx$!);
    next if ($i =~ m!^(vnl|vil|vil1|vsl|vul|vpl|vgl|vgl_algo|vbl)_fwd$! || $i =~ m!^vgui_glu?x?t?$! || $i eq "StdAfx");
    next if ($i =~ m!^mil_! && $f =~ m!\bmul/mil/mil_all\.h$!);
    next if ($j eq "mil/mil_all.h" && $f =~ m!\bmul/mil/mil_add_all_loaders\.cxx$!);
    next if ($i =~ m!^(v.l)_io_! && $f =~ m!/$1/io/!);
    next if ($i =~ m!^accessors/vipl_accessors_! && $f =~ m!/v[ie]pl2?/!);
    next if ($i =~ m!^vbl_sparse_array_[123]d$! && $f =~ m!vbl/io/vbl_io_sparse_array_[123]d\.h$!);
    next if ($i eq "vcl_string" && $f =~ m!vgui/impl/gtk/(vgui_gtk_adaptor\.h|Templates/vcl_vector\+GtkWidget\~-\.cxx)$!);
    next if ($j eq "vsol/vsol_line_2d.h" && $f =~ m!bbas/bgui/bgui_vsol_soview2D\.cxx$!);
    $ii = $i;
    $i =~ s!^([vb]gui.*)!$1\(\|_sptr\|_new\)!;
    $i =~ s!^(v(so|to|dg|cs)l.*)!$1\(\|_sptr\)! unless ($f =~ m!\.h$!);
    # VCL
    if ($j eq "vcl_algorithm.h") { $i="vcl_(adjacent_find|and|binary|binary_search|copy|copy_|count|count_if|equal|equal_range|fill|fill_n|find|find_end|find_first_of|find_if|for_each|generate|generate_n|generators_|heap|includes|inplace_merge|iter_swap|lexicographical_compare|lower_bound|make_heap|max|min|max_element|merge|merge_|min_element|mismatch|next_permutation|nth_element|partial_sort|partial_sort_copy|partition|stable_partition|partitions_|pop_heap|prev_permutation|push_heap|random_shuffle|remove|remove_copy|remove_copy_if|remove_if|replace|replace_copy|replace_copy_if|replace_if|reverse|reverse_copy|rotate|rotate_copy|search|search_n|set_difference|set_intersection|set_symmetric_difference|set_union|sort|sort_|sort_heap|stable_sort|swap|swap_|swap_ranges|transform|unique|unique_copy|upper_bound)"; }
    elsif ($j eq "vxl_config.h") { $i="VXL_[A-Z_0-9]+|vxl_([su]\?(int|ieee)_(8|16|32|64)|s\?byte)"; }
    elsif ($j eq "vcl_cassert.h") { $i="assert"; }
    elsif ($j eq "vcl_cctype.h") { $i="(vcl_|)(isalnum|isdigit|isprint|isupper|tolower|isalpha|isgraph|ispunct|isxdigit|toupper|iscntrl|islower|isspace)"; }
    elsif ($j eq "vcl_cerrno.h") { $i="(errno|EBUSY|EEXIST)"; }
    elsif ($j eq "vcl_cfloat.h") { $i="(FLT_MAX|DBL_MAX|MAXFLOAT|MAXDOUBLE)"; }
    elsif ($j eq "vcl_climits.h") { $i="(CHAR_BIT|CLK_TCK)"; }
    elsif ($j eq "vcl_cmath.h") { $i="vcl_(abs|acos|asin|atan|atan2|ceil|cos|cosh|exp|fabs|floor|fmod|frexp|ldexp|log|log10|modf|pow|sin|sinh|sqrt|tan|tanh)|hypot"; }
    elsif ($j eq "vcl_complex.h") { $i="vcl_(complex|real|imag|abs|arg|norm|conj|polar|cos|cosh|exp|log|log10|pow|sin|sinh|sqrt|tan|tanh)"; }
    elsif ($j eq "vcl_complex.h" && $f =~ m!/tests/test_cmath\.cxx$!) { $i=""; }
    elsif ($j eq "vcl_csetjmp.h") { $i="(setjmp|vcl_(jmp_buf|longjmp))"; }
    elsif ($j eq "vcl_csignal.h") { $i="vcl_(sig_atomic_t|raise|signal)"; }
    elsif ($j eq "vcl_cstdarg.h") { $i="(vcl_|)va_list"; }
    elsif ($j eq "vcl_cstddef.h") { next if ($f =~ m!\bcore/vil1?(/file_formats)?/vil1?_jpeglib\.h$!); $i="vcl_(ptrdiff_t|size_t)"; }
    elsif ($j eq "vcl_cstdio.h") { next if ($f =~ m!\b(vcl/vcl_cassert|core/vil1?(/file_formats)?/vil1?_jpeglib)\.h|\bcore/vul/vul_temp_filename\.cxx$!); $i="vcl_(FILE|fpos_t|fopen|fclose|feof|ferror|fflush|fgetc|fgetpos|fgets|fwrite|fread|fseek|ftell|perror|clearerr|rename|fputc|fputs|freopen|fsetpos|getc|getchar|gets|putc|putchar|puts|remove|rewind|setbuf|setvbuf|tmpfile|tmpnam|ungetc|printf|sprintf|fprintf|vprintf|vsprintf|vfprintf|scanf|sscanf|fscanf|vscanf|vsscanf|vfscanf)"; }
    elsif ($j eq "vcl_cstdlib.h") { next if ($f =~ m!\bvcl/vcl_cassert\.h$!); $i="(vcl_(abs|div|labs|ldiv|srand|rand|atexit|getenv|system|exit|abort|qsort|calloc|malloc|free|realloc|atol|atof|atoi|mblen|mbstowcs|mbtowc|strtod|strtol|strtoul|wctomb|wcstombs)|[sd]rand48)"; }
    elsif ($j eq "vcl_cstring.h") { $i="vcl_(memchr|memcmp|memcpy|memmove|memset|strcat|strchr|strcmp|strcoll|strcpy|strcspn|strerror|strlen|strncat|strncmp|strncpy|strpbrk|strrchr|strspn|strstr|strtok|strxfrm)"; }
    elsif ($j eq "vcl_ctime.h") { $i="vcl_(clock_t|time_t|tm|asctime|clock|difftime|localtime|strftime|ctime|gmtime|mktime|time)"; }
    elsif ($j eq "vcl_cwchar.h") { $i="vcl_(mbstate_t|wint_t|btowc|fgetwc|fgetws|fputwc|fputws|fwide|fwprintf|fwscanf|getwc|getwchar|mbrlen|mbrtowc|putwc|putwchar|swprintf|swscanf|ungetwc|vfwprintf|vswprintf|vwprintf|wcrtomb|wcscat|wcschr|wcscmp|wcscoll|wcscpy|wcscspn|wcsftime|wcslen|wcsncat|wcsncmp|wcsncpy|wcspbrk|wcsrchr|wcsrtombs|wcsspn|wcsstr|wcstod|wcstok|wcstol|wctoul|wcsxfrm|wctob|wmemchr|wmemcmp|wmemcpy|wmemmove|wmemset|wprintf|wscanf)"; }
    elsif ($j eq "vcl_cwctype.h") { $i="vcl_(wctrans_t|wctype_t|wint_t|iswalnum|iswalpha|iswcntrl|iswctype|iswdigit|iswgraph|iswlower|iswprint|iswpunct|iswspace|iswupper|iswxdigit|iswctrans|iswupper|iswxdigit|towctrans|towlower|towupper|wctrans|wctype)"; }
    elsif ($j eq "vcl_deque.h") { $i="vcl_(deque|swap)"; }
    elsif ($j eq "vcl_deprecated.h") { $i="vcl_deprecated_(warn|abort)|VXL_DEPRECATED"; }
    elsif ($j eq "vcl_exception.h") { $i="vcl_(exception|bad_exception|throw|catch|catch_all)"; }
    elsif ($j eq "vcl_fstream.h") { next if ($f =~ m!\bvcl/(Templates/f?stream|vcl_iostream)!); $i="vcl_(filebuf|fstream|ifstream|ofstream)"; }
    elsif ($j eq "vcl_functional.h") { $i="vcl_((|pointer_to_)(unary|binary)_(function|negate)|plus|minus|multiplies|divides|modulus|negate|(|not_)equal_to|(greater|less)(|_equal)|logical_(and|or|not)|not(1|2)|bind(|er)(1st|2nd)|ptr_fun|(|const_)mem_fun(|1)(|_ref)(_t|)|transform)"; }
    elsif ($j eq "vcl_iomanip.h") { $i="vcl_((re|)setiosflags|set(base|fill|precision|w)|(no|)(boolalpha|showbase|showpoint|showpos|skipws|uppercase)|internal|left|right|dec|hex|oct|fixed|scientific)"; }
    elsif ($j eq "vcl_ios.h") { next if ($f =~ m!\bvcl_iomanip\.h$!); $i="vcl_(ios|streamoff|streamsize|fpos|basic_ios|ios_((base|float|adjust)field|(no|)(boolalpha|showbase|showpoint|showpos|skipws|uppercase)|internal|left|right|dec|hex|oct|fixed|scientific|fmtflags|seekdir|beg|cur|end))"; }
    elsif ($j eq "vcl_iosfwd.h") { $i="vcl_((basic_||w)(io|i|o|if|of|f|(|i|o)string)stream|streamoff|char_traits|allocator|(basic||w)_ios|(basic_||w)(stream|string|file)buf|(i|o)streambuf_iterator|fpos|(|w)streampos)"; }
    elsif ($j eq "vcl_istream.h") { $i="vcl_(basic_||w)i(|o)stream"; }
    elsif ($j eq "vcl_iostream.h") { next if ($f =~ m!/(vcl_ios\.h|StdAfx\.h)$!); $i="(vcl_(cin|cout|cerr|clog|(i|o)stream|endl|ends|flush|stream(pos|buf|size)|hex|oct|dec|ws|setfill|setprecision|setw|fixed|scientific)|vgui_macro_warning)"; }
    elsif ($j eq "vcl_iterator.h") { next if ($f =~ m!\brpl/rrel/rrel_util\.h$!); $i="vcl_(iterator_traits|(|reverse_|(i|o)stream(|buf)_|(back_|front_|)insert_)iterator|(|back_|front_)inserter|(input|output|forward|bidirectional|random_access)_iterator_tag|advance|distance)"; }
    elsif ($j eq "vcl_limits.h") { $i="vcl_(numeric_limits|float_round_style|float_denorm_style)"; }
    elsif ($j eq "vcl_list.h") { $i="vcl_(list|swap)"; }
    elsif ($j eq "vcl_locale.h") { $i="vcl_(use_facet|has_facet|isspace|isprint|iscntrl|isupper|islower|isalpha|isdigit|ispunct|isxdigit|isalnum|isgraph|toupper|tolower|ctype|codecvt_base|(codecvt|collate|(num|money)punct|time_(get|put)|messages)(|_byname)|(num|money)(_get|_put))"; }
    elsif ($j eq "vcl_map.h") { $i="vcl_(map|multimap|swap)"; }
    elsif ($j eq "vcl_memory.h") { $i="vcl_(allocator|raw_storage_iterator|get_temporary_buffer|return_temporary_buffer|uninitialized_copy|uninitialized_fill|uninitialized_fill_n|auto_ptr)"; }
    elsif ($j eq "vcl_new.h") { $i="new"; }
    elsif ($j eq "vcl_numeric.h") { $i="vcl_(accumulate|inner_product|partial_sum|adjacent_difference)"; }
    elsif ($j eq "vcl_ostream.h") { $i="vcl_((basic_||w)ostream|endl|ends|flush)"; }
    elsif ($j eq "vcl_queue.h") { $i="vcl_(|priority_)queue"; }
    elsif ($j eq "vcl_set.h") { $i="vcl_(set|multiset|swap)"; }
    elsif ($j eq "vcl_sstream.h") { $i="vcl_((basic_||w)stringbuf|(|i|o)stringstream)"; }
    elsif ($j eq "vcl_stack.h") { $i="vcl_stack"; }
    elsif ($j eq "vcl_stlfwd.h") { next; }
    elsif ($j eq "vcl_stdexcept.h") { $i="vcl_(logic_error|domain_error|invalid_argument|length_error|out_of_range|runtime_error|range_error|overflow_error|underflow_error)"; }
    elsif ($j eq "vcl_streambuf.h") { $i="vcl_(basic_|)streambuf"; }
    elsif ($j eq "vcl_string.h") { $i="vcl_(char_traits|(basic_||w)string|swap|getline)"; }
    elsif ($j eq "vcl_strstream.h") { $i="vcl_(|i|o)strstream"; }
    elsif ($j eq "vcl_typeinfo.h") { $i="typeid|vcl_(type_info|bad_cast|bad_typeid)"; }
    elsif ($j eq "vcl_utility.h") { $i="vcl_(pair|make_pair)"; }
    elsif ($j eq "vcl_valarray.h") { $i="vcl_(valarray|slice|slice_array|gslice|gslice_array|mask_array|indirect_array|abs|acos|asin|atan|atan2|cos|cosh|exp|log|log10|pow|sin|sinh|sqrt|tan|tanh)"; }
    elsif ($j eq "vcl_vector.h") { $i="vcl_(vector|swap)"; }
    # VBL
    elsif ($j eq "vbl/vbl_basic_optional.h") { $i="$i(|_traits)"; }
    elsif ($j eq "vbl/vbl_bounding_box.h") { $i="$i(|_base)"; }
    elsif ($j eq "vbl/vbl_br_default.h") { $i="$i(|_iter|_wild_iter|_factory)"; }
    elsif ($j eq "vbl/vbl_qsort.h") { $i="$i(|_(double|int|)(a|de)scending|_helper)"; }
    elsif ($j eq "vbl/vbl_sort.h") { $i="($i)_((double|int|)(a|de)scending|helper)"; }
    # VBL-IO
    elsif ($j eq "vbl/io/vbl_io_smart_ptr.h") { $i="$i|_IO_INSTANTIATE.*_sptr"; }
    # VUL
    elsif ($j eq "vul/vul_arg.h") { $i="$i(|_parse|_include|_display_usage_and_exit|_info_list)"; }
    elsif ($j eq "vul/vul_string.h") { $i="$i(_c_|_)((up|down)case|capitalize|(|left|right)trim|reverse|atoi|atof|bool|expand_var)"; }
    # VPL
    elsif ($j eq "vpl/vpl.h") { $i="($i)_(getcwd|mkdir|rmdir|chdir|unlink|sleep|usleep|putenv)"; }
    # VSL
    elsif ($j eq "vsl/vsl_binary_io.h") { $i="vsl_b_(read|write|[io]f\?stream)"; }
    elsif ($j eq "vsl/vsl_block_binary.h") { $i="($i)_(read|write)"; }
    elsif ($j eq "vsl/vsl_binary_loader.h") { next if ($f =~ m!/Templates/(\S+\~-|vbl_io_smart_ptr\+\S+)\.cxx$!); $i="$i|vsl_b_(read|write)|vsl_delete_all_loaders"; }
    elsif ($j eq "vsl/vsl_binary_explicit_io.h") { $i="vsl_(convert_[a-z_]+|swap_bytes|swap_bytes_to_buffer|b_(read|write)_[a-z_]+)"; }
    elsif ($j eq "vsl/vsl_complex_io.h") { $i="(VNL_IO_[A-Z]+_INSTANTIATE.vcl_complex|vsl_b_(read|write))"; }
    elsif ($j eq "vsl/vsl_indent.h") { $i="$i(|_inc|_dec|_set_tab|_tab|_clear|_clear_all_data)"; }
    # VGL
    elsif ($j eq "vgl/vgl_clip.h") { $i="$i(|_type|_line[a-z_]+)"; }
    elsif ($j eq "vgl/vgl_convex.h") { $i="$i(_hull)"; }
    elsif ($j eq "vgl/vgl_closest_point.h") { $i="$i(|s|_origin|_to_linesegment|_to_(|non_)closed_polygon)"; }
    elsif ($j eq "vgl/vgl_distance.h") { $i="($i)(|_origin|(|2)_to_linesegment|_to_(|non_)closed_polygon)"; }
    elsif ($j eq "vgl/vgl_lineseg_test.h") { $i="$i(_line|_lineseg)"; }
    elsif ($j eq "vgl/vgl_triangle_test.h") { $i="($i)_(discriminant|inside)"; }
    elsif ($j eq "vgl/algo/vgl_homg_operators_2d.h") { $i="($i|vnl_double_3x3[^\000]*vgl_homg_point_2d|cond_matrix . x)"; }
    elsif ($j eq "vgl/algo/vgl_homg_operators_3d.h") { $i="($i|vnl_double_4x4[^\000]*vgl_homg_point_3d|p_matrix_ \\* X)"; }
    # VIL & VIL1
    elsif ($j =~ m"vil1/vil1_\d+bit\.h$") { $i="($i)(|_(read|write)_(big|little)_endian)"; }
    elsif ($j =~ m"vil/vil_bi(lin|cub)_interp\.h$") { $i="($i)(|_safe|_unsafe|_raw|_safe_extend)"; }
    elsif ($j eq "vil1/vil1_clamp.h") { $i="$i(|_pixel)"; }
    elsif ($j eq "vil/vil_clamp.h") { $i="$i(|_below|_image_resource)"; }
    elsif ($j eq "vil1/vil1_colour_space.h") { $i="($i)_(RGB|HSV)_to_(YIQ|HSV|RGB)"; }
    elsif ($j eq "vil/vil_config.h") { $i="HAS_[A-Z]+"; }
    elsif ($j eq "vil/vil_convert.h") { $i="($i)_((cast|round)(|_pixel)|(rgb|planes)_to_grey|stretch_range|to_[a-z_]+)"; }
    elsif ($j eq "vil1/vil1_convolve.h") { $i="($i)_(signal_[12]d|1d_[xy]|separable|boundary_option|trim|[a-z]+_extend)"; }
    elsif ($j eq "vil/vil_copy.h") { $i="($i)(|_deep|_to_window|_reformat)"; }
    elsif ($j eq "vil/vil_fill.h") { $i="($i)_(line|row|col|mask)"; }
    elsif ($j eq "vil/vil_flip.h") { $i="($i)_(ud|lr)"; }
    elsif ($j eq "vil1/vil1_image_as.h") { $i="$i(|(_rgb_|_)(byte|uint16|int|float|double))"; }
    elsif ($j eq "vil/vil_image_resource.h") { $i="$i(|_sptr)"; }
    elsif ($j eq "vil/vil_image_resource_sptr.h") { $i="vil_image_resource(|_sptr)"; }
    elsif ($j eq "vil/vil_image_view.h") { $i="$i(|_deep_equality)"; }
    elsif ($j eq "vil/vil_image_view_base.h") { $i="$i(|_sptr)"; }
    elsif ($j eq "vil1/vil1_interpolate.h") { $i="($i)_(nearest|bilinear(|_grad)|bicubic)"; }
    elsif ($j eq "vil/vil_load.h") { $i="$i(|_image_resource(|_raw))"; }
    elsif ($j eq "vil/vil_math.h") { $i="($i)_([a-z_]+)"; }
    elsif ($j eq "vil/vil_memory_chunk.h") { $i="$i(|_sptr)"; }
    elsif ($j eq "vil1/vil1_memory_image.h") { $i="$i(|_format)"; }
    elsif ($j eq "vil/vil_nearest_neighbour_interp.h") { $i="$i(|_safe|_safe_extend)"; }
    elsif ($j eq "vil/vil_new.h") { $i="($i)_image_(resource(|_of_view)|view_j_i_plane|view_plane_i_j)"; }
    elsif ($j =~ m"vil1?/vil1?_pixel\.h$") { $i="($i)_format(|_t|_component_format)"; }
    elsif ($j =~ m"vil1?/vil1?_pixel_format\.h$") { $i="($i(|_of|_component_format|_sizeof_components|_num_components)|VIL_PIXEL_FORMAT_\\S+)"; }
    elsif ($j =~ m"vil1?/vil1?_property\.h$") { $i="$i(|_[a-z_]+)"; }
    elsif ($j eq "vil/vil_print.h") { $i="($i)(|_value|_all)"; }
    elsif ($j eq "vil/vil_rotate.h") { $i="$i(_image)"; }
    elsif ($j eq "vil/vil_save.h") { $i="$i(|_image_resource)"; }
    elsif ($j eq "vil1/vil1_smooth.h") { $i="($i)_(gaussian|byte_separable_symmetric)"; }
    elsif ($j =~ m"vil/vil_stream_(read|write)\.h$") { $i="($i)_(big|little)_endian_[a-z0-9_]+"; }
    elsif ($j eq "vil/vil_transform.h") { $i="($i)(|2)"; }
    elsif ($j eq "vil/vil_view_as.h") { $i="($i)(|_planes|_rgb)|vil_view_(real|imag)_part"; }
    elsif ($j eq "vil1/vil1_vil.h") { $i="vil1_(to_|from_|)vil_image_(view|resource)"; }
    elsif ($j eq "vil1/vil1_warp.h") { $i="$i(|_mapping|_interpolation_type|_output_driven)"; }
    # VIL/FILE_FORMATS
    elsif ($j eq "vil/file_formats/vil_dicom_header.h") { $i = "($i(_type|_endian|_image_type|_info|_format))|VIL_DICOM_HEADER_[A-Z0-9_]+"; }
    elsif ($j =~ m"vil/file_formats/vil_nitf_") {} # keep $i
    elsif ($j =~ m"vil1?/(file_formats/|)vil1?_jpeglib\.h$") { $i="jpeg(|1|2)_[a-z_]+"; }
    elsif ($j =~ m"vil1?/file_formats/(.*)\.h") { $i="$1_file_format"; }
    # VIL/ALGO
    elsif ($j eq "vil/algo/vil_cartesian_differential_invariants.h") { $i="($i)_3"; }
    elsif ($j eq "vil/algo/vil_convolve_1d.h") { $i="vil_convolve_(1d|edge_1d|boundary_option)"; }
    elsif ($j eq "vil/algo/vil_find_peaks.h") { $i="vil_(find_peaks_3x3|is_peak_3x3)"; }
    elsif ($j eq "vil/algo/vil_find_4con_boundary.h") { $i="$i(_below|_above)_threshold"; }
    elsif ($j eq "vil/algo/vil_histogram.h") { $i="$i(|_byte)"; }
    elsif ($j eq "vil/algo/vil_exp_filter_1d.h") { $i="vil_exp_filter_(1d|i|j)"; }
    elsif ($j eq "vil/algo/vil_exp_grad_filter_1d.h") { $i="vil_exp_grad_filter_(1d|i|j)"; }
    elsif ($j eq "vil/algo/vil_gauss_filter.h") { $i="($i)_(5tap(|_params)|gen_ntap)"; }
    elsif ($j eq "vil/algo/vil_gauss_reduce.h") { $i="$i(|_params|_general|_121)"; }
    elsif ($j eq "vil/algo/vil_fft.h") { $i="$i(|_2d_fwd|_2d_bwd)"; }
    elsif ($j eq "vil/algo/vil_orientations.h") { $i="$i(|_at_edges|_from_sobel)"; }
    elsif ($j eq "vil/algo/vil_suppress_non_max.h") { $i="vil_(is_peak|suppress_non_max)_3x3"; }
    # VIL/IO
    elsif ($j eq "vil/io/vil_io_memory_chunk.h") { $i="($i|vsl_b_write|VIL_IO_SMART_PTR_INSTANTIATE.vil_memory_chunk)"; }
    elsif ($j eq "vil1/io/vil1_io_rgb.h") { $i="($i|vsl_b_write|VIL1_IO_MEMORY_IMAGE_OF_INSTANTIATE.vil1_rgb)"; }
    # VNL
    elsif ($j eq "vnl/algo/vnl_algo_fwd.h") { $i="vnl_(svd|qr|matrix_inverse|symmetric_eigensystem|cholesky|complex_eigensystem|conjugate_gradient|cpoly_roots|lbfgs|levenberg_marquardt)"; }
    elsif ($j eq "vnl/algo/vnl_chi_squared.h") { $i="($i)_[a-z]+"; }
    elsif ($j eq "vnl/algo/vnl_fft.h") { $i="$i(|_(|set)gpfa)"; }
    elsif ($j eq "vnl/algo/vnl_netlib.h") { $i="(zgeev|rpoly|dchscdf|dpofa|dposl|dpoco|dpodi|dgpfa|rsg|dgges|lbfgs|lmdif|lsqr|qrdc|qrsl|rs|rg|dnlaso|svdc)_"; }
    elsif ($j eq "vnl/algo/vnl_symmetric_eigensystem.h") { $i="$i(|_compute)"; }
    elsif ($j eq "vnl/algo/vnl_discrete_diff.h") { $i="$i(_sym|_fwd|_test_lsf)"; }
    elsif ($j eq "vnl/vnl_bignum_traits.h") { $i="vnl_bignum"; }
    elsif ($j eq "vnl/vnl_rational_traits.h") { $i="vnl_rational"; }
    elsif ($j eq "vnl/vnl_complex.h") { $i="vcl_complex"; }
    elsif ($j eq "vnl/vnl_cross.h") { $i="vnl_cross_[23]d"; }
    elsif ($j eq "vnl/vnl_erf.h") { $i="vnl_erfc\?"; }
    elsif ($j eq "vnl/vnl_error.h") { $i="$i(|_[a-z_]+)"; }
    elsif ($j eq "vnl/vnl_finite.h") { $i="($i)_int(|_poly)"; }
    elsif ($j eq "vnl/vnl_inverse.h") { $i="$i(|_transpose)"; }
    elsif ($j eq "vnl/vnl_gamma.h") { $i="vnl_((|log_)gamma(|_[pq])|cum_prob_chi2)"; }
    elsif ($j eq "vnl/vnl_math.h") { $i="vnl_(math(|_[a-z_]+)|huge_val)"; }
    elsif ($j eq "vnl/vnl_matlab_print.h") { $i="($i|MATLABPRINT)"; }
    elsif ($j eq "vnl/vnl_matlab_print2.h") { $i="(vnl_matlab_print|VNL_MATLAB_PRINT2_INSTANTIATE)"; }
    elsif ($j eq "vnl/vnl_matlab_read.h") { $i="$i(|hdr)"; }
    elsif ($j eq "vnl/vnl_sparse_matrix.h") { $i="$i(|_pair)"; }
    elsif ($j eq "vnl/vnl_T_n.h") { $i="($i)_[a-z_]*"; }
    elsif ($j eq "vnl/vnl_sample.h") { $i="$i(|_[a-z_]+)"; }
    elsif ($j eq "vnl/vnl_tag.h") { $i="($i)_[a-z]+"; }
    elsif ($j eq "vnl/vnl_matrix_fixed_ref.h") { $i="$i(|_const)"; }
    elsif ($j eq "vnl/vnl_vector_fixed_ref.h") { $i="$i(|_const)"; }
    elsif ($j eq "vnl/vnl_config.h") { $i="VNL_CONFIG_(CHECK_BOUNDS|LEGACY_METHODS|THREAD_SAFE)"; }
    # VGUI
    elsif ($j eq "vgui/vgui_adaptor.h") { $i="(vgui|get)_(adaptor|event)"; }
    elsif ($j eq "vgui/vgui_color_text.h") { $i="(text_to_color|(red|green|blue)_value)"; }
    elsif ($j eq "vgui/vgui_command.h") { $i="($i(|_[a-z_]+)|VGUI_COMMAND_SIMPLE_INSTANTIATE)"; }
    elsif ($j eq "vgui/vgui_find.h") { $i="($i)_[a-z_]+name"; }
    elsif ($j eq "vgui/vgui_grid_tableau.h") { $i="$i(_data|)"; }
    elsif ($j eq "vgui/vgui_macro.h") { $i="$i(|_[a-z_]+)"; }
    elsif ($j eq "vgui/vgui_menu.h") { $i="$i(|_item)"; }
    elsif ($j eq "vgui/vgui_pixel.h") { $i="($i)_([rgba1568]*|rgbfloat)"; }
    elsif ($j eq "vgui/vgui_rubberband_tableau.h") { $i="vgui_rubberband(_tableau(|_new|_sptr)|(|_easy2D)_client)"; }
    elsif ($j eq "vgui/vgui_shell_tableau.h") { $i="$i(_bindings|)"; }
    elsif ($j eq "vgui/vgui_soview2D.h") { $i="$i(|_point|_circle|_lineseg|_linestrip|_polygon|_group|_image)"; }
    elsif ($j eq "vgui/vgui_statusbar.h") { $i="($i|get_statusbar\(\)->)"; }
    elsif ($j eq "vgui/vgui_style.h") { $i="$i(_equal|)"; }
    elsif ($j eq "vgui/vgui_tag.h") { $i="$i(|_[a-z_]+)"; }
    elsif ($j eq "vgui/vgui_tableau_sptr.h") { $i="($i(|_t)|get_tableau)"; }
    elsif ($j eq "vgui/internals/vgui_rasterpos.h") { $i="($i).*"; }
    elsif ($j eq "vgui/internals/vgui_simple_field.h") { $i="vgui_(simple|bool|int|long|float|double)_field"; }
    # VIDL
    elsif ($j eq "vidl/vidl_codec.h") { $i="$i|coder_->"; }
    elsif ($j eq "vidl_vil1/vidl_vil1_codec.h") { $i="$i|coder_->"; }
    elsif ($j eq "vidl/vidl_frame.h") { $i="$i|->get_(view|image)\(\)"; }
    elsif ($j eq "vidl_vil1/vidl_vil1_frame.h") { $i="$i|get_view"; }
    # VIPL
    elsif ($j eq "vipl/filter/vipl_filter_abs.h") { $i="($i|FILTER_IMPTR_(INC|DEC)_REFCOUNT)"; }
    elsif ($j =~ m"vipl/vipl_with_vbl_array_2d/accessors/vipl_accessors_(vbl_array_2d)\.h") { $i="$1"; }
    elsif ($j eq "vepl/vepl_monadic.h") { $i="$i(|_[a-z_]+)"; }
    elsif ($j eq "vepl/vepl_dyadic.h") { $i="$i(|_[a-z_]+)"; }
    elsif ($j eq "vepl2/vepl2_monadic.h") { $i="$i(|_[a-z_]+)"; }
    elsif ($j eq "vepl2/vepl2_dyadic.h") { $i="$i(|_[a-z_]+)"; }
    # VDGL
    elsif ($j eq "vdgl/vdgl_digital_curve.h") { $i="$i|cast_to_digital_curve\(\)|get_interpolator\(\)"; }
    elsif ($j eq "vdgl/vdgl_edgel_chain.h") { $i="$i|get_edgel_chain\(\)|vbl_smart_ptr.txx"; }
    elsif ($j eq "vdgl/vdgl_interpolator.h") { $i="$i|get_interpolator\(\)|vbl_smart_ptr.txx"; }
    elsif ($j eq "vdgl/vdgl_interpolator_sptr.h") { $i="vdgl_interpolator(|_sptr)"; }
    # VSOL
    elsif ($j eq "vsol/vsol_point_2d.h") { $i="$i|p[01]\(\)"; }
    elsif ($j eq "vsol/vsol_spatial_object_2d.h") { $i="$i|cast_to_spatial_object_2d\(\)"; }
    elsif ($j eq "vsol/vsol_curve_2d.h") { $i="$i|cast_to_curve\(\)"; }
    # VTOL
    elsif ($j eq "vtol/vtol_vertex_2d.h") { $i="$i|cast_to_vertex_2d\(\)"; }
    elsif ($j eq "vtol/vtol_edge_2d.h") { $i="$i|cast_to_edge_2d\(\)"; }
    elsif ($j eq "vtol/vtol_face_2d.h") { $i="$i|cast_to_face_2d\(\)"; }
    elsif ($j eq "vtol/vtol_zero_chain.h") { $i="$i|outside_boundary_zero_chains\(\)"; }
    elsif ($j eq "vtol/vtol_topology_object.h") { $i="$i|cast_to_topology_object\(\)|(topology|vertex|(|zero_|one_|two_)chain|edge|face|block)_list"; }
    elsif ($j eq "vtol/vtol_dtd.h") { $i="$i([0123])"; }
    elsif ($j eq "vtol/vtol_list_functions.h") { $i="(tagged_union|(SEL|COPY)_(SUP|INF))"; }
    elsif ($j eq "vtol/vtol_macros.h") { $i="(SEL|COPY)_(SUP|INF)"; }
    # BDGL
    elsif ($j =~ m"bdgl/bdgl_curve_(tracker|matcher|matching|tracking|clustering)\.h$") { $i="$i(|_params)"; }
    elsif ($j eq "bdgl/bdgl_tracker_curve.h") { $i="$i|match_data|[sg]et_best_match_(prev|next)\(\)"; }
    elsif ($j eq "bdgl/utils.h") { $i="fixAngleMPiPi|fixAngleZTPi|angleDiff"; }
    # GEVD
    elsif ($j eq "gevd/gevd_pixel.h") { $i="(byte|char|short|float|ptr)Pixel"; }
    # MBL
    elsif ($j eq "mbl/mbl_cloneable_ptr.h") { $i="($i|MBL_CLONEABLE_PTR_INSTANTIATE)"; }
    elsif ($j eq "mbl/mbl_combination.h") { $i="$i(_begin|_next)"; }
    elsif ($j eq "mbl/mbl_gamma.h") { $i="mbl_(gamma_[pq]|erf)"; }
    elsif ($j eq "mbl/mbl_matrix_products.h") { $i="mbl_matrix_product(|_a_bt|_at_b|_adb)"; }
    elsif ($j eq "mbl/mbl_matxvec.h") { $i="($i)_(prod|add)_[a-z_]+"; }
    elsif ($j eq "mbl/mbl_test.h") { $i="($i)_summaries_are_equal"; }
    elsif ($j eq "vnl/io/vnl_io_vector.h") { $i="($i|MBL_FILE_DATA_[A-Z]+_INSTANTIATE.vnl_vector)"; }
    # MIL
    elsif ($j eq "mil/mil_bilin_interp_2d.h") { $i="mil(|_safe(|_extend))_bilin_interp_2d"; }
    elsif ($j eq "mil/mil_convert_vil.h") { $i="($i)_[gc][mv]2[gc][mv]"; }
    # VIMT
    elsif ($j eq "vimt/algo/vimt_find_peaks.h") { $i="vimt_(is_peak(|_3x3)|find_(image|world)_peaks(|_3x3)|find_max)"; }
    elsif ($j eq "vimt/algo/vimt_find_throughs.h") { $i="vimt_(is_through_3x3|find_(image|world)_throughs_3x3)"; }
    elsif ($j eq "vimt3d/vimt3d_trilin_interp.h") { $i="($i)_(safe|raw)"; }
    # VPDFL
    elsif ($j eq "vpdfl/vpdfl_prob_chi2.h") { $i="vpdfl_(cum_prob_chi2|chi2_for_cum_prob)"; }
    # RREL
    elsif ($j eq "rrel/rrel_misc.h") { $i="$i(|_[a-z_]+)"; }
    elsif ($j eq "rrel/rrel_muse_table.h") { $i="$i(|_entry)|rrel_muse_key_type"; }
    elsif ($j eq "rrel/rrel_util.h") { $i="$i(|_[a-z_]+)"; }
    # RSDL
    elsif ($j eq "rsdl/rsdl_dist.h") { $i="$i(|_[a-z_]+)"; }
    elsif ($j eq "rsdl/rsdl_kd_tree.h") { $i="rsdl_kd_(node|heap_entry|tree"; }
    # RGRL
    elsif ($j eq "rgrl/rgrl_feature.h") { $i="$i(|_caster)"; }
    elsif ($j eq "rgrl/rgrl_mask.h") { $i="$i(|_[a-z_]+)"; }
    elsif ($j eq "rgrl/rgrl_match_set.h") { $i="$i(|_[a-z_]+_iterator)"; }
    elsif ($j eq "rgrl/rgrl_scale_estimator.h") { $i="$i(|_(un|)wgted)"; }
    elsif ($j eq "rgrl/rgrl_util.h") { $i="$i(|_[a-z_]+)"; }
    # BGUI
    elsif ($j eq "bgui/bgui_vsol_soview2D_point.h") { $i="$i(|_[a-z_]+)"; }
    # SPECIAL CASES
    if ($j =~ m"(vsl/vsl_[a-z]+_io|v[bginu]l1?/io/v[bginu]l1?_io_[a-z123_]+)\.h") { $i="$i|vsl_(b_(read|write)|print_summary)"; }
    next if ($j eq "vsol/vsol_curve.h" && $f =~ m!Templates/vbl_smart_ptr\+vtol_edge-\.cxx$!);
    next if ($j eq "vsol/vsol_point.h" && $f =~ m!Templates/vbl_smart_ptr\+vtol_edge-\.cxx$!);
    next if ($j eq "vsol/vsol_region.h" && $f =~ m!Templates/vbl_smart_ptr\+vtol_face-\.cxx$!);
    next if ($j eq "vsol/vsol_curve_2d.h" && $f =~ m!Templates/vbl_smart_ptr\+vtol_edge_2d-\.cxx$!);
    next if ($j eq "vsol/vsol_point_2d.h" && $f =~ m!Templates/vbl_smart_ptr\+vtol_edge_2d-\.cxx$!);
    next if ($j eq "vsol/vsol_region_2d.h" && $f =~ m!Templates/vbl_smart_ptr\+vtol_face_2d-\.cxx$!);
    # FINALLY PRINT MESSAGE, IF APPLICABLE
    &msg(1, "should not have #include <$j>")
      unless ($fl =~ m!$j\>[^\003]*\b$i\b! || $f =~ m!/$ii\.! || $f =~ m!\btests/test_include\.cxx$!);
  }
  &msg(1, "should have \#include <vcl_cassert.h>")
    if (! $found_cassert && $file =~ m!\n\s*assert\s*\(!);
  &msg(1, "should have \#include <vcl_iostream.h> or <vcl_iosfwd.h>")
    if (! $found_iostream && $f =~ m!\.h$! && $f !~ m!vcl_! && $f !~ m!core/vgui/vgui_macro.h$! &&
        $fl =~ m!\bvcl_(cin|cout|cerr|clog|(i|o)stream|endl|ends|flush|stream(pos|buf|size))\b!);

  &msg(1, "suspicious $1")
    if ($f !~ m!\bvcl/\S*vcl_\S+\.(h|txx)$! &&
        $file =~ m!(\#\s*include\s*\"([^\"]*)/[^\"]*\")! &&
        $2 ne "internals" && $2 ne ".." && $2 ne "../accessors" && $2 ne "os_unix" && $2 ne "vc70" &&
        $1 ne "# include  \"emulation/vcl_limits.cxx\"");
  if ($cpp_file && $f !~ m!\bvcl/\S*vcl_\S+\.(h|txx)$! &&
      $file =~ m!\#\s*include\s*\<(assert|ctype|errno|float|iso646|limits|locale|math|setjmp|signal|stdarg|stddef|stdio|stdlib|string|time|wchar|wctype)\.h\>!) {
    $t=$1;
    &msg(1, "replace #include <$t.h> by #include <vcl_c$t.h>")
      unless (($f =~ m!\bcore/vnl/vnl_math\.cxx$! && $t eq "math") ||
              ($f =~ m!\bvcl/tests/test_driver\.cxx$! && $t eq "math") ||
              ($f =~ m!\bcore/testlib/testlib_main\.cxx$! && $t eq "math") ||
              ($f =~ m!\bcore/vnl/vnl_sample\.cxx$! && $t eq "stdlib") ||
              ($f =~ m!\bcore/vpl/os_unix/vpl\.cxx$! && $t eq "stdlib") ||
              ($f =~ m!/cmake/config/vxl_platform_tests\.cxx$!) ||
              ($f =~ m!\bcore/vul/vul_temp_filename\.cxx$! && $t eq "stdio") ||
              ($f =~ m!\bcore/vul/vul_redirector\.cxx$! && $t eq "stddef"));
  }
  &msg(1, "local $2 should come before global $1")
    if ($file =~ m!(\#\s*include\s*\<[^\>]*\>).*(\#\s*include\s*\"[^\"]*\")!);

# 7. //: inside a comment block, or \file not after //:
  &msg(1, "\\file is not preceded by //:")
    if ($file =~ m!\n\s*(//[^:]|[^\s/]).*\n *// *\\file\b!);
  $file =~ s!//\s*[-=_]{40,}\n!//\n!g;
  &msg(1, "contains //: inside a comment block")
    if ($file =~ m!\n\s*//[ :].*\n *//:!);

# 8. Comments: long /* ... */ and old-style // -- docs; RCS indications; mistypings
  $file =~ s! +\n!\n!g;
  $file =~ s!/\*!\001!g; $file =~ s!/\001!//\*!g;
  $file =~ s!\*/!\002!g;
  $file =~ s!(\"[^\001\n\"]{0,15})\001([^\001\n\"]{0,15}\")!$1/\*$2!g;
  $file =~ s!(\"[^\002\n\"]{0,15})\002([^\002\n\"]{0,15}\")!$1\*/$2!g;
  $file =~ s!\001\*!/\*\*!g; # Doxygen style comments
  if ($file =~ m!//\s*[a-zA-Z_0_9]*\s*--\s+(\S*)! && $1 ne "JLM")
  {
    &msg(1, "contains old style // -- docs")
      unless ($f =~ m!vcl/vcl_complex_fwd\.h$! || $f =~ m!win32-vc60/vcl_complex\.h$! || $f =~ m!vgui/vgui_glut\.h$!);
  }
  &msg(1, "contains long /*...*/ comments")
    if ($cpp_file && $f !~ m!\bvidl/vidl_mpegcodec\.cxx$! && $f !~ m!\bvidl_vil1/vidl_vil1_mpegcodec\.cxx$! &&
        $f !~ m!\bvul/vul_url\.cxx$! && $f !~ m!\bvcl/gtkgl/! &&
        $f !~ m!\bvul/tests/test_file_iterator\.cxx$! && $file =~ m!\001[^\001\002]{111,}\002!);
  if ($file =~ m!\n\s*//\s*vcl_c(out|err)\s*\<\<.*(\n\s*//.*){5,}! && $file !~ m!//\s*\\code!)
  {
    $tmp=$file; $tmp =~ s!\n\s*//\s*vcl_c(out|err)\s*\<\<.*(\n\s*//.*){5,}[^\000]*!!; $tmp =~ s![^\n]*!!g; $tmp=length($tmp)+2;
    &msg($tmp, "consider commenting out code sections with #if 0 or #ifdef DEBUG");
  }
  # RCS indications
  &msg(1, "contains RCS indication $1")
    if ($file =~ m!(\$RCSfile|\$(Author|Revision|Date): .* \$)!);
  #typos
  &msg(1, "probably a mistyping: $1")
    if ($file =~ m!\b(accom[^mp]\S*|accp\S+|accura[^ct]\S*|adaptati[^no]\S*|[a-z]*(sss|ettt)[a-z]*|alement|alife|anj\b|appi\S+|arang\S+|arbitar\S+|aready|argree|argume[^n]\S*|assemb[^l]\S*|assignement|authentification|auxil[^i]\S*|auxiliar\b|ayn\S+|azimutha|bandwith|begining|blted|bondar\S*|borgefor\b|chac\S*|changeb\S*|cic[^ae]\S*|cirl[a-z]+|cir[^c]\S[a-z]+|coeffic[^i]\S*|coefi[a-z]+|coli[a-z]{4,}|colum[^n]|columnn[^u]|coma\S*|comparis[^o]\S*|compatibil[^i]\S*|compilant|condt\S+|conju[^gnr]\S*|(con|de)stuct\S*|(con|de)truct\S*|containins|continou\S*|contrain\S+|contor|continguous|controled|coordi[^n]\S*|cores\S+|corr[a-dfghj-np-tv-z][a-z]+\b|decend\S*|(de)?compos[^aei]\S*|defau[^l]\S*|dependan\S*|dependen[^ct]\S*|desct\S*|despatch|difu[a-z]+|digtial|dimensi[^o]\S*|dimensionn\S*|distingish|documen[^t-]\S*|doen|effic[^ai]\S*|eigenval[a-rtv-z]\S*|elm[ei]\S+|encapsu[^l]\S*|encounterd|enquiries|epipl\S+|eq[a-tv-z][a-z]{5,}|esti[^m]\S*|Eucl[^i]\S*|Euclidi\S*|expalin|expri\S*|exr[a-z]{3,}|filname|fomat|fractino|frequence|functo[^r]|funct[^io]\S*|graid\S*|hasnt|heigth|heir\S+|hiera[^r]\S*|hight|highligh[^t]\S*|(non)?homege\S*|(non)?homog[a-df-qs-z]\S*|(non)?homogeni[^sz]\S*|(non)?homogen[^ei]\S*|identia\S*|implemen[^t]\S*|implementat[^i]\S*|incredibably|indentic\S*|independant|indicies|inheranc\S*|inhert\S*|initi[^a][a-z]*|initialli\S+|interat\S*|inte[^glmnrs]\S*|inti[^m][a-z]*|judicous|kernal|lable|lenth|likely[a-z]\S*|lik[^aei]\S*|magnit[^u]\S*|maint[^ae]\S*|matricies|maxiu\S*|maximu[^m]|measur[^ei]\S*|mili[^t]\S*|minmu\S*|minimia\S*|minina\S*|miscel[^l]\S*|necc\S*|neces[^s]\S*|objects\'s|obje[^c]\S*|occur[a-qt-z]\S*|octo[^b]\s*|oor|openned|orienta[^lt]\S*|ouput|outputing|parallal|parameteric|paramete[^r]\S*|paramt\S*|parap[^h]\S*|parbol|perf[^eiou]\S*|perim[a-df-z]\S*|polyon|posi[^tx]\S*|posti[^n]\S*|pote[^n]\S*|prefered|progam\S*|protocal|receip[^t]|(re)?determing|refern|regu[^l]\S*|rep[eo]n[a-z]{4,}|represe[^n]\S*|reps[a-z]{2,}|retrei\S*|rre[a-z]*q\S*|samp[a-km-rt-z][a-z]*|seciton|seting|severl\S*|simulat[^eio]\S*|singlt\S*|singlet[^o]\S*|staig\S*|subsit\S*|substra\S*|succes[^s]\S*|supres\S*|supp[^elor]\S*|syme\S*|symmet[^r]\S*|syte\S*|tableaus|tablea[^nu]\S*|tableu|talbeau|tech[a-mo-z]\S*|teh|tesselat\S*|thse|togg[^l]\S*|toler[^a]\S*|tran[a-prt-z]\S*|transf[^23eiou ]\S*|traver[^s]\S*|unec\S+|utilitit[^iy]|valu[^ae]\S*|verf\S*|verson|verticies|vertexes|vlo\S*|whan|wether|whou\S*|wil\b|wrapi\S*|writted|yei\S*)!i
        && $1 ne "valush" && $1 ne "IntInfo" && $1 ne "InitInstance" && $1 ne "sss" && $1 ne "ttt" && $1 !~ m!^(.*GlassSel.*)$!);

# 9. spurious #pragma interface or #pragma implementation
  &msg(1, "contains $1 without #ifdef VCL_NEEDS_PRAGMA_INTERFACE")
    if ($file !~ m!\#ifdef VCL_NEEDS_PRAGMA_INTERFACE\n(\#pragma (interface|implementation)).*\n\#endif\n! &&
        $file =~ m!(\#\s*pragma\s+(interface|implementation))\b!);

# Now remove comments and string constants before checking further:
  $file_s = "\n" . $file;
  # continuation lines:
  $file_s =~ s!\\\n!!g;
  $file_s =~ s!\n\#if\s+0\s*\n.*?\n\#endif\s*\n!\n!g;
  # remove string constants, incl. multiline string constants with "correct syntax":
  $file_s =~ s!\'\"\'!!g;
  $file_s =~ s!([^\\])(\\\")+!$1!g;
  $file_s =~ s!\".*?\"!\003!g;
  # replace :: by \005 and -> by \006 (useful later)
  $file_s =~ s!::!\005!g;
  $file_s =~ s!->!\006!g;
  # remove // comments
  $file_s =~ s!//.*\n!\n!g;
  # remove /* ... */ comments
  $file_s =~ s!(\001|/\*)[^\001\002]*\002!!g;
# &msg(1, "contains nested comments")
#   if ($file_s =~ m![\001\002]!);

# 10. Multi-line string constant
  &msg(1, "contains multi-line string constant")
    if ($file_s =~ m!\"!);
# 11. Inclusion guard and file name
  if ($file_s =~ m!^\s*\#ifndef\s+(\S+)\s*\n\#define\s+\1\s*(\s.*)?\n!)
  {
    $guard = $1;
    if (defined($inclusion_guards{"$guard"}))
    {
      &msg(1, "has the same inclusion guard as " . $inclusion_guards{"$guard"} . "");
    }
    else
    {
      $inclusion_guards{"$guard"} = "$f";
    }
    &msg(1, "last line: change $2 to $guard")
      if ($file =~ m!\#endif\s*(//|/\*)\s*(\S+)\s*(\*/)?$! && $2 ne $guard);
    undef $guard;
  }
  else
  {
    &msg(1, "has no (valid) inclusion guard")
      if ($cpp_file && $f =~ m!\.(txx|h)$! &&
          $f !~ m!vcl/vcl_typeinfo\.h$! &&
          $f !~ m!copyright\.h$! &&
          $f !~ m!/resource\.h$!i &&
          $file_s ne "\n");
  }

  if ($file =~ m!//\s*This\s+is\s+([^\s]+)\n!)
  {
    $filename = $1; $pwd = `pwd`; chop($pwd);
    $file_ = $f; $file_ = "$pwd/$f" unless $f =~ m!^/!;
    while ($file_ =~ m!/\.\./!) { $file_ =~ s![^/]+/\.\./!!g; }
    while ($file_ =~ m!/\./!) { $file_ =~ s!/\./!/!g; }
    $file_ =~ s!^.*/(config|vcl|v3p|core|contrib)/!$1/!; $file_ =~ s!^contrib/!!;
    &msg(1, "has // This is $filename, should be $file_")
      unless ("$filename" eq "$file_");
  }

# 12. Constant pi written as 3.1415...
  &msg(1, "should maybe use vnl_math::pi instead of $1")
    if ($f !~ m!\b(v[cuib]l|v3p)/! && $f !~ m!\bcore/vnl/vnl_math\.! &&
        $cpp_file && $file_s =~ m!\b(3\.14159\d*)!);

# 13. Instantiation macro stuff
  &msg(1, "definition of $1 ends with ;")
    if ($file_s =~ m!\#define\s+(\S*INSTANTIATE[^\s\(\)]*).+;\s*\n!);
  &msg(1, "definition of $1 does not start with a space")
    if ($file_s =~ m!\#define\s+(\S*INSTANTIATE[^\s\(\)]*)\s*\([^)]*\)\S!);
  &msg(1, "definition of $1 has no space before > in $2")
    if ($file_s =~ m!\#define\s+(\S*INSTANTIATE[^\s\(\)]*).+(\<[^<>\n]*[A-Za-z_][A-Za-z_0-9]*\>)! && $2 ne "<float>" && $2 ne "<double>");
# Presence of VCL_*_INSTANTIATE in *.cxx files outside Templates directories
  &msg(1, "$1 may only be used in Templates subdirectories")
    if ($f !~ m!/Templates/! &&
        $f !~ m!vcl/tests/test_rel_ops\.cxx$! &&
        $f !~ m!core/vsl/tests/test_polymorphic_io\.cxx$! &&
        $f !~ m!core/vbl/tests/vbl_test_classes\.cxx$! &&
        $f !~ m!core/vbl/examples/vbl_smart_ptr_example\.cxx$! &&
        $f !~ m!oxl/ogui/examples/awf/glmovie\.cxx$! &&
        $f !~ m!oxl/apps/glmovie/glmovie.cxx$! &&
        $file_s =~ m!\n\s*(VCL_[_A-Z]*INSTANTIATE[_A-Z]*)! &&
        "$1" ne "VCL_INSTANTIATE_INLINE");
# Check correct file name of *.cxx files in Templates directories
  $file_s =~ s!VCL_DO_NOT_INSTANTIATE!VCL_do_not_INSTANTIATE!g;
  if ($f =~ m!/Templates/! &&
      $f !~ m!vcl/Templates/(complex|string)-instances\.cxx$! &&
      $f !~ m!core/vnl/algo/Templates/fsm_pack\.cxx$! &&
      $f !~ m!core/vbl/examples/Templates/smartptr-instances\.cxx$! &&
      $f !~ m!core/vnl/Templates/vnl_matrix_fixed_pairwise_ops\.cxx$! &&
      $file_s =~ m!\b([_A-Z0-9]*)_INSTANTIATE\s*\((.*)\)!)
  {
    $class=$1; $class =~ tr/A-Z/a-z/; $class="$class<$2>";
    $class =~ s!\bvcl_(swap|containable)\s*\<!vcl_algorithm\<!g;
    $class =~ s!\bvcl_sort\s*\<[^,]+\,!vcl_algorithm\<!g;
    $class =~ s!\bvcl_find(_if)?\s*\<\s*vcl_(vector|list)\s*\<([^\005]+)\005\s*(const_)?iterator.+!vcl_algorithm\<$3!g;
    while ($file_s =~ s!\btypedef\s+([^;]*)\s(\S+)\s*\;!!)
    { $A=$1; $B=$2; $B =~ s!([][{}()|*+/\\])!\\$1!g; $class =~ s!\b$B\b!$A!g; }
#   $class =~ s!\bconst\b!!g;
    $class =~ s!\s!!g;
    $class =~ s!\bconstchar!const_char!g; $class =~ s!(\w)const([^r])!$1_const$2!g;
    $class =~ s!\,vcl_less\<[^<>]+\<[^<>]+\>[^<>]*\>!!g;
    $class =~ s!\,vcl_less\<[^<>]+\>!!g;
    $class =~ s!\,(.*)_sptr\,\1\005compare!!g;
    $class =~ s!(vbl_io_sparse_array)_base\<!$1\<!g;
    $class =~ s!\005!+-!g; $class =~ tr/<,*>/+.~-/; # \005 is ::
    $class_q = $class; $class_q =~ s!([.+~-])!\\$1!g;
    $class =~ s!unsigned!u!g; $class =~ s!signed!s!g; $class =~ s!longd!long_d!g;
    $class =~ s!vxl_(s?byte|u?int)!$1!g;
    $class_r = $class; $class_r =~ s!([.+~-])!\\$1!g;
    $class_s = $class_q; $class_s =~ s!signed!signed_!g; $class_s =~ s!long!long_!g;
    &msg(1, "should be renamed to $class.cxx")
      if ($f !~ m!/$class_q\.(cxx|cc|C)$! &&
          $f !~ m!/$class_r\.(cxx|cc|C)$! &&
          $f !~ m!/$class_s\.(cxx|cc|C)$!);
  }

# 14. Missing vcl_
  foreach $wd (split(' ',"abort exit"))
  {
    if ($cpp_file && $file_s =~ m!\b$wd\s*(\s*)\(!)
    {
      &msg(1, "$wd$1() must be vcl_$wd()")
        unless ($f =~ m!/cmake/config/vxl_platform_tests\.cxx$!);
    }
  }

  foreach $wd (split(' ',"complex real imag conj arg polar min max abs acos asin atan atan2 ceil cos cosh exp fabs floor fmod frexp ldexp log log10 modf pow sin sinh sqrt tan tanh printf fprintf sprintf scanf fscanf sscanf fopen fclose fread fwrite memchr memcpy memcmp memmove memset qsort strcat strncat strcpy strncpy strchr strcmp strncmp strcoll strcspn strerror strlen strpbrk strrchr strspn strstr strtok strxfrm isspace isprint iscntrl isupper islower isalpha isgraph isdigit ispunct isxdigit isalnum isgraph toupper tolower"))
  {
    &msg(1, "$wd$1() must be vcl_$wd()")
      if ($cpp_file &&
          "$f.$wd" !~ m!\bvul_timer\.(h|cxx)\.real$! &&
          "$f.$wd" !~ m!\bvnl_quaternion\.h\.real$! &&
          "$f.$wd" !~ m!\bvnl/tests/test_complex\.cxx\.acos$! &&
          "$f.$wd" !~ m!\bmbl_arb_length_int\.h\.abs$! &&
          "$f.$wd" !~ m!\bvnl_(bignum|rational)\.h\.abs$! &&
          "$f.$wd" !~ m!\bvnl/(vnl_rational\.h|tests/test_rational\.cxx)\.(ceil|floor)$! &&
          "$f.$wd" !~ m!\bvnl_finite\.h\.(exp|log|pow)$! &&
          "$f.$wd" !~ m!\bvil1?_rgb\.(h|txx)\.(min|max)$! &&
          "$f.$wd" !~ m!\bvbl_bounding_box\.(h|txx)\.(min|max)$! &&
          "$f.$wd" !~ m!\bvgel/kl/base\.h\.(min|max)$! &&
          "$f.$wd" !~ m!\bmbl_stats_1d\.h\.(min|max)$! &&
          "$f.$wd" !~ m!\brgrl_spline\.cxx\.(ceil|floor|min|max)$! &&
          "$f.$wd" !~ m!\brgrl/tests/test_spline\.cxx\.(ceil|floor)$! &&
          "$f.$wd" !~ m!\bmvl/HomgConic\.(h|cxx)\.polar$! &&
          "$f.$wd" !~ m!\bbdgl_curve_clustering\.(cxx|h)\.(min|max)$! &&
          "$f.$wd" !~ m!\bbsta_histogram\.h\.(min|max)$! &&
          "$f.$wd" !~ m!\balgo/vnl_rn?poly_(solve|roots)\.h\.(real|imag)$! &&
          "$f"     !~ m!/cmake/config/vxl_platform_tests\.cxx$! &&
          $file_s =~ m![^.\005\006]\b$wd(\s*)\(! ); # \005 is :: and \006 is ->
  }
  foreach $wd (split(' ',"cin cout cerr clog endl ends flush ios istream ostream fstream ifstream ofstream strstream ostrstream streambuf streamoff streamsize fpos streampos stringstream"))
  {
    &msg(1, "$wd must be vcl_$wd")
      if ($cpp_file && $f !~ m!\bvcl/Templates/stream-instances\.cxx$! &&
          $f !~ m!\bvcl/tests/test_driver\.cxx$! &&
          $f !~ m!/cmake/config/vxl_platform_tests\.cxx$! &&
          $file_s =~ m![^ .]\s*\b$wd\b\s*[^ (]! );
  }
  foreach $wd (split(' ',"basefield floatfield adjustfield fmtflags seekdir"))
  {
    &msg(1, "$wd must be vcl_ios_$wd")
      if ($cpp_file && $file_s =~ m![^ .]\s*\b$wd\b\s*[^ (]!);
  }
  foreach $wd (split(' ',"beg cur end"))
  {
    &msg(1, "$wd must be vcl_ios_$wd")
      if ($cpp_file &&
          ($wd !~ m!end! ||
           ($f !~ m!\boxp/oxp_mpeg_codec\.cxx$! &&
            $f !~ m!\bvil3d_slice_list\.cxx$! &&
            $f !~ m!\b(rrel/rrel_util|rsdl/rsdl_borgefors)\.txx$! ) ) &&
          $file_s =~ m!,\s*$wd\s*\)! );
  }
  foreach $wd (split(' ',"boolalpha noboolalpha showbase noshowbase showpoint noshowpoint showpos noshowpos skipws noskipws uppercase nouppercase"))
  {
    &msg(1, "$wd must be vcl_ios_$wd")
      if ($cpp_file && $file_s =~ m![^ .]\s*\b$wd\b\s*[^ (]!);
    &msg(1, "$wd() must be vcl_$wd()")
      if ($cpp_file && $file_s =~ m!\b$wd\s*\(!);
  }
  foreach $wd (split(' ',"internal left right"))
  {
    &msg(1, "$wd must be vcl_ios_$wd")
      if ($cpp_file &&
          ($wd !~ m!(left|right)! ||
           ($f !~ m!\bpdf1d_pdf\.cxx$! &&
            $f !~ m!\bvnl_matrix(|_fixed(|_ref))\.txx|algo/vnl_complex_eigensystem\.cxx$! &&
            $f !~ m!\b(vsl_conic_points|gevd_float_operators|vcsl_tutor)\.cxx$! &&
            $f !~ m!\bvtol_extract_topology\.(h|cxx|txx)$! &&
            $f !~ m!\brgrl_invariant_match\.(cxx|h)$! &&
            $f !~ m!\brsdl_(bins_2d|kd_tree)\.h$! &&
            $f !~ m!\brsdl/(rsdl_kd_tree|tests/test_bins_2d|tests/test_kd_tree)\.cxx$! ) ) &&
          $file_s =~ m![^ .>]\s*\b$wd\s*[|),]! );
    &msg(1, "vcl_ios_$wd must be used together with vcl_ios_adjustfield")
      if ($cpp_file &&
          $file_s =~ m!\bvcl_ios_$wd\s*[^ ,]! &&
          $file_s !~ m!(vcl_resetiosflags|\.\s*unsetf)\s*\((vcl_ios_(internal|left|right)\s*\|\s*)*vcl_ios_$wd\s*(\|\s*vcl_ios_(internal|left|right)\s*)*\)! );
    &msg(1, "$wd() must be vcl_$wd()")
      if ($cpp_file &&
          ($f !~ m!\boxl/oxp/vsl_conic_points\.cxx$! || $wd !~ m!(left|right)! ) &&
          $file_s =~ m!\b$wd\s*\(!);
  }
  foreach $wd (split(' ',"dec hex oct"))
  {
    &msg(1, "$wd must be vcl_ios_$wd")
      if ($cpp_file && $file_s =~ m!\b$wd\s*[|),]!);
    &msg(1, "vcl_ios_$wd must be used together with vcl_ios_basefield")
      if ($cpp_file && $file_s =~ m!\bvcl_ios_$wd\s*[^ ,]! &&
          $file_s !~ m!(vcl_resetiosflags|\.\s*unsetf)\s*\((vcl_ios_(dec|hex|oct)\s*\|\s*)*vcl_ios_$wd\s*(\|\s*vcl_ios_(dec|hex|oct)\s*)*\)!);
    &msg(1, "$wd() must be vcl_$wd()")
      if ($cpp_file && $file_s =~ m!\b$wd\s*\(!);
  }
  foreach $wd (split(' ',"scientific fixed"))
  {
    &msg(1, "$wd must be vcl_ios_$wd")
      if ($cpp_file &&
          ($f !~ m!\b(vpdfl/vpdfl_pc_gaussian_builder|bgui_bargraph_clipon_tableau)\.! || $wd !~ m!^fixed$!) &&
          $file_s =~ m!\b$wd\s*[|),]!);
    &msg(1, "vcl_ios_$wd must be used together with vcl_ios_floatfield")
      if ($cpp_file && $file_s =~ m!\bvcl_ios_$wd\s*[^ ,]! &&
          ($f !~ m!\bvpdfl/vpdfl_pc_gaussian_builder\.! || $wd !~ m!^fixed$!) &&
          $file_s !~ m!(vcl_resetiosflags|\.\s*unsetf)\s*\((vcl_ios_(scientific|fixed)\s*\|\s*)*vcl_ios_$wd\s*(\|\s*vcl_ios_(scientific|fixed)\s*)*\)!);
    &msg(1, "$wd() must be vcl_$wd()")
      if ($cpp_file && $file_s =~ m!\b$wd\s*\(!);
  }
  foreach $wd (split(' ',"size_t ptrdiff_t clock_t time_t"))
  {
    &msg(1, "$wd must be vcl_$wd")
      if ($cpp_file && $file_s =~ m!\b$wd\b!);
  }
  foreach $wd (split(' ',"iterator_traits back_insert_iterator front_insert_iterator insert_iterator input_iterator_tag output_iterator_tag forward_iterator_tag bidirectional_iterator_tag random_access_iterator_tag"))
  {
    &msg(1, "$wd must be vcl_$wd")
      if ($cpp_file && $f !~ m!\bvcl/.*\bvcl_iterator\.(h|txx)$! && $file_s =~ m!\b$wd\b!);
  }

# 15. Multiple empty lines, empty line before } or after {, return (...), indentation,
#   if/for/while without space, variable name starting with underscore
#   (mentioned only if something else is already printed, or when -f given)
  &msg(1, "contains multiple (>2) empty lines")
    if ($printed && $file =~ m!\n\n\n\n!);
  &msg(1, "has lines ending in spaces")
    if ($printed && $has_end_spaces);
  &msg(1, "has empty lines before closing brace")
    if ($printed && $file =~ m!\n\n[ \t]*\};*\s*\n!);
  &msg(1, "has empty lines after opening brace")
    if ($printed && $file =~ m!\n[ \t]*\{\s*\n\n!);
  &msg(1, "has empty lines after function header")
    if ($printed && $file =~ m!\n[ \t]*\n\{!);
  &msg(1, "Replace \"$1 (0)\" by \"$1 (false)\"")
    if ($printed && $cpp_file && $file =~ m!\b(if|while)\s*\(\s*0\s*\)!);
  &msg(1, "Replace \"$1 (1)\" by \"$1 (true)\"")
    if ($printed && $cpp_file && $file =~ m!\b(if|while)\s*\(\s*1\s*\)!);
  $f_=$fl;
  while ($printed && $f_ =~ s!\n([^()\'\";\n]*\( *)((\([^();\n]*\))*[^();\n]+(\([^();\n]*\)[^();\n]*)*)\n( +)([+-] *)!\n$5$6!)
  {
    $line="$1$2"; $first=$2; $post="$5"; $ppost="$6"; $pre="$1"; $pre =~ s!.! !g; $ppost =~ s!.! !g;
    &msg(1, "incorrect indentation in line following \"$line\"")
      unless ($pre eq $post || $pre eq $post.$ppost || $line =~ m!_INSTANTIATE_! || $line =~ m!\<\<! || $first eq "//");
  }
  $f_=$fl; $f_ =~ s!\"[^\n\"]*\"!Q!g; $f_ =~ s!\'\\?.\'!Q!g; $f_ =~ s!\<\<!\007!g;
  while ($printed && $f_ =~ s!\n([^\007;{}\#\n]*)(\007[^;\n]*)\n( +)\007!\n$3\007!)
  {
    $line="$1$2"; $pre="$1"; $post="$3"; next if ($pre =~ m!^\s*$!);
    $line =~ s!\007!\<\<!g; $pre =~ s!.! !g;
    &msg(1, "incorrect indentation in line following \"$line\"")
      unless ($pre eq $post);
  }
  if ($printed && $file =~ m!\n( *)(\S+).*\n(\1 +)\{ *\n\3 ! && $2 !~ m!\#(if|ifdef|else|endif)!) {
    $tmp=$file; $tmp =~ s!\n( *)\S.*\n(\1 +)\{ *\n\2 [^\000]*!!; $tmp =~ s![^\n]*!!g; $tmp=length($tmp)+3;
    &msg($tmp, "excess indentation in code block around line $tmp");
  }
  undef $f_;
  &msg(1, "$1 not preceded by space")
    if ($printed && $file =~ m!\n(public|private|protected)\s*\:!);
  &msg(1, "$1 preceded by more than one space")
    if ($printed && $file =~ m!  (public|private|protected)\s*\:!);
  &msg(1, "No empty line between two function bodies")
    if ($printed && $file =~ m!\n};? *\n([a-zA-Z]+)! && $1 ne "typedef");
  &msg(1, "Consider placing opening brace of function body on new line")
    if ($printed && $file =~ m!\n([a-zA-Z]\S*).* (\S+) *\{ *\n! && $1 ne "extern" && $1 ne "struct" && $2 ne "=");
  &msg(1, "$1 not followed by space")
    if ($printed && $file =~ m!\b(for|if|while|switch)\(!);
  &msg(1, "return value in brackets")
    if ($printed && $file =~ m!\breturn\s*\([^;()]*(\([^;()]*\)[^;()]*)*\)\s*;!);
  &msg(1, "delete value in brackets")
    if ($printed && $file =~ m!\n [^\n]*\bdelete\s*\([^;()]*(\([^;()]*\)[^;()]*)*\)\s*;!);
  $file =~ s!^\#.*!!g; $file =~ s!\n\#.*!!g;
  &msg(1, "$2 starts with underscore")
    if ($cpp_file && $printed && $file_s =~ m!([^\"\# ] *\b|^)(_[a-z][a-zA-Z0-9_]*)(.)! && "$2$3" ne "_fmemset(" && "$2$3" ne "_declspec(");

# 16. too long { ... } section with the "{" not on the start of a line
  &msg(1, "has a block of more than 24 lines with the opening brace not on a line by itself")
    if ($printed && $file =~ m!\S *\{ *\n( +)\S.*\n(\1.*\n){24}!);

# 17. no end-of-line at end-of-file
  $file =~ s!.*\n!!g;
  &msg(1, "has no final end-of-line")
    unless ($file eq "");
}

sub msg
{
  local($linenum,$message) = @_;
  if ($emacs)  { print "$f:$linenum:\t\# $message\n"; }
  elsif ($vim) { print "vim +$linenum $f\t\# $message\n"; }
  else         { print "$f\t\# $message\n"; }
  $printed = 1;
}
