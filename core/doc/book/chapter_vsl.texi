@chapsummary
This section describes how to save and restore objects using a binary stream.
It details how to add the appropriate functions to each class to make use
of this facility.
@endchapsummary

All objects in VXL should be able to save themselves to a stream (eg a file)
and restore (load) themselves from a stream (file). The main functions provided
for this purpose are @code{vsl_b_write(os,object);} and @code{vsl_b_read(is,object&);}.

The binary IO for the core libraries (vbl, vil, vgl and vnl) is implemented in `clip-on'
libraries which live in the @code{io} subdirectories of each library (thus the
declaration of the function @code{vsl_b_write(vsl_b_ostream&,const vnl_vector&);}
lives in the file @file{vnl/io/vnl_io_vector.h}.

However, it is recommended that I/O for other libraries be provided by writing
@code{b_write(os);} and @code{b_read(is);} functions in each class.  See the
`Design Notes' section below.

@section Supported Platforms

The binary I/O code is known to work across the following hardware/OS/compiler
combinations, but probably also works on most other platform/compiler combinations:

@enumerate
@item  Intel - Linux - gcc-2.95 and gcc-3.0
@item  Intel - WindowsNT - vc++
@item  SGI - MIPS - MipsPRO CC
@item  Sun - Solaris - gcc-2.95
@item  DEC alpha - OSF - gcc-2.95 and gcc 3.0 (64 bit!)
@end enumerate

Thus
binary files produced by any of the above should be readable by any other of the above.
There is of course a minor exception: large numbers (like integers larger than 4294967295)
saved on a 64-bit platform cannot be read on a 32-bit platform.

@subsection caveats
The code has been designed to work on as many platforms as possible. However if your
platform uses any of the following, then it will probably not work (as presently coded.)
@enumerate
@item  A middle endian word encoding scheme.
@item  Chars of length other than 8 bits.
@item  Non-IEEE format floats and doubles.
@end enumerate

@section Using Binary I/O

To save an object to a file, simply do the following:
@example
vxl_myclass my_object;

// Fill my_object

vsl_b_ofstream bfs("my_object.bvl");
if (!bfs)
@{
    vcl_cerr<<"Failed to open my_object.bvl for output."<<vcl_endl;
@}
else
@{
    vsl_b_write(bfs,my_object);
    bfs.close();
@}
@end example

To load/restore the object from a file:

@example
vxl_myclass my_new_object;

vsl_b_ifstream bfs("my_object.bvl");
if (!bfs)
@{
    vcl_cerr<<"Failed to open my_object.bvl for input."<<vcl_endl;
@}
else
@{
    vsl_b_read(bfs,my_object);
    bfs.close();
@}
@end example

It is recommended that the default extension name for your binary files is @code{.bvl}.
This extension does not appear to be used by any other program. In many cases however, you
will want to pick a new extension to indicate the contents of a file. For example, we store
active shape model objects with ending @code{.asm}.

The classes @code{vsl_b_ifstream} and @code{vsl_b_ofstream} are simple wrappers around
real @code{vcl_ifstream} and @code{vcl_ofstream} objects. These wrappers ensure that
you open a file with CR/LF conversion turned off, and they should also allow lots of
common misuses to be caught at compile time.

The functions @code{vsl_b_write(os,X)} and @code{vsl_b_read(is,X)} are defined for all
reasonable cases, including all inbuilt types, most classes in vcl and the classes in
the core vxl libraries.

When you write a new class, you should add the appropriate functions to allow easy
use of binary I/O (see below).

Or for simplicity we provide the utility functions which would allow you to write:

@example
#include <vsl/vsl_quick_file.h>
vxl_myclass my_object,my_new_object;

vsl_quick_file_save("my_object.bvl",my_object);
vsl_quick_file_load("my_object.bvl",my_new_object);
@end example


@subsection Saving multiple objects
One can use exactly the same approach to save a set of objects

@example
vxl_myclass my_object;
vxl_my_other_class my_other_object;

// Fill objects
// ...

vsl_b_ofstream bfs("my_object.bvl");
if (!bfs)
@{
    vcl_cerr<<"Failed to open my_object.bvl for output."<<vcl_endl;
@}
else
@{
    vsl_b_write(bfs,my_object);
    vsl_b_write(bfs,my_other_object);
    bfs.close();
@}
@end example

(and similarly for loading them).

A standard rule for ensuring trouble free I/O is
@quotation
Always write the input and output code in tandem - the output should
precisely mirror the input.
@end quotation



@subsection Binary I/O by baseclass pointer

When using polymorphism, there are frequently times when one needs to
save and restore an object just using a base class pointer to it.
@code{vsl} provides facilities to do this.

Assuming class @code{my_derived} is derived from class @code{my_base}, the following
will work.

To save an object by baseclass:

@example
my_derived d;

my_base *b = &d;

vsl_b_ofstream bfs("data.bvl");
vsl_b_write(bfs,b);
...
@end example

To restore an object:
@example
// Make application aware of possible classes that it might see in the file

vsl_add_to_binary_loader(my_derived());
vsl_add_to_binary_loader(my_derived2());
...


my_base *b = 0;

vsl_b_ifstream bfs("data.bvl");
vsl_b_read(bfs,b);
// b now points to the correct class which has been created
// on the heap and filled with the data from bfs
...
@end example

Note that the read function will only work if the application has been made
aware of each of the possible derived classes that it might come across in the
file.  This is done using calls to @code{vsl_add_to_binary_loader(my_derived())}
(see below for details).

To reduce the pain of doing this, many libraries have a function that adds all
the relevant derived classes (eg @code{xxxx_add_all_binary_loaders()} where
@code{xxxx} is the library name).

@subsection Which files do I need to include/link?

In general the vsl_b_read and vsl_b_write functions use Koenig Lookup - that is the location
of their declaration depends on their parameters.

The @code{vsl_b_stream} objects and @code{vsl_b_write} and @code{vsl_b_read} functions
for fundamental data types are declared in @code{<vsl/vsl_binary_io.h>}. If you want to
load or save a @code{vcl_vector}, the appropriate @code{vsl_b_write} and @code{vsl_b_read}
functions will be in @code{<vsl/vsl_vector_io.h>}. Likewise for most of the other vcl classes.
The @code{vsl} library contains the implementation of all of this.

When reading/writing by baseclass pointer, you need to include @code{vsl/vsl_binary_loader.h}.

If you want to load or save a @code{vgl_point_2d}, you will need to include
@code{<vgl/io/vgl_io_point_2d.h>} and similarly for all other Level-1 VXL libraries. You
will need to include the vgl_io library.
For Level-2 libraries, the situation varies. If binary io has been defined at all for a
level-2 library, it might be included in the library itself, e.g. the io functions for
vpdfl_gaussian are declared in the same file as the Gaussian, @code{vpdfl/vpdfl_gaussian.h>}.
Alternatively, it might be in a clip-on library in the same form as the Level-1 libraries
above.

@subsection How to save templated objects

The situation for templated objects is the same as above, except that you need to ensure that
the appropriate (templated) @code{vsl_b_read} and @code{vsl_b_write} functions are explicitly instantiated.
This instantiation is achieved by placing a file in the relevant "Templates" folder.

An example template file, is shown below. It enables saving of a 2d array of "@code{hjk_model}"s
(a completely made up plain class).

@example
// file = my_module/hjk/Templates/vbl_array_2d_io+hjk_model~-.cxx
#include <vbl/io/vbl_io_array_2d.txx>
#include <hjk/hjk_model.h>
VBL_IO_ARRAY_2D_INSTANTIATE(hjk_model);
@end example

The @code{vbl_io_array_2d.txx} file contains the @code{VBL_IO_ARRAY_2D_INSTANTIATE} macro and the
@code{hjk_model.h} file contains the io header declarations for a plain class.

Another example template file, allowing the saving of a vector of @code{vgl_point_2d} objects,
is shown below.

@example
// file = my_module/hjk/Templates/vsl_vector_io+vgl_point_2d~-.cxx
#include <vsl/vsl_vector_io.txx>
#include <vgl/io/vgl_io_point_2d.h>
VSL_VECTOR_IO_INSTANTIATE(vgl_point_2d<double>);
@end example

The @code{vsl_vector_io.txx} file contains the @code{VSL_VECTOR_IO_INSTANTIATE} macro and the
@code{vgl_io_point_2d.h} file contains the io header declarations for @code{vgl_point_2d<double>}.

You should now be able to load and save templated objects with lines such as:-

@example
vcl_vector<hjk_model> hjk_model_vec;
vsl_b_ofstream bfs("hjk_model_vec.bvl");
if (!bfs)
@{
    vcl_cerr<<"Failed to open hjk_model_vec.bvl for output."<<vcl_endl;
@}
else
@{
    vsl_b_write(bfs,hjk_model_vec);
    bfs.close();
@}
@end example

NB, the template instantiation files should be placed in your own libraries (ie here "hjk") to
avoid creating unnecessary and unused versions of a given templated function.



@section Tidy Printing with @code{vsl_indent}

The utility functions and class in @code{vsl_indent} give a way of putting
indentation into output streams to give more legible printed output.

If each class implements it's printing (print(os) or print_summary(os))
in such a way that at the beginning of each new line one inserts an
indentation using
@example
os<<vsl_indent()<<"Rest of stuff.."<<vcl_endl;
@end example
and increases and decreases the current indentation for the stream with
@code{vsl_indent_inc(os)} and @code{vsl_indent_dec(os)},
then one can easily generate readable output for complex nested sets
of classes.

It's use is best described by example:

@example
vcl_cout<<vsl_indent()<<"No Indent"<<vcl_endl;
vsl_indent_inc(vcl_cout);
vcl_cout<<vsl_indent()<<"1 Indent"<<vcl_endl;
vsl_indent_inc(vcl_cout);
vcl_cout<<vsl_indent()<<"2 Indent"<<vcl_endl;
vsl_indent_dec(vcl_cout);
vcl_cout<<vsl_indent()<<"1 Indent"<<vcl_endl;
vsl_indent_dec(vcl_cout);
vcl_cout<<vsl_indent()<<"No Indent"<<vcl_endl;
@end example

This produces output of the form
@example
No Indent
  1 Indent
    2 Indent
  1 Indent
No Indent
@end example

Example of use in class output:
@example
class Fred
@{
public:
  void print(vcl_ostream& os) const @{ os<<vsl_indent(os)<<"Fred's data"; @}
@};

vcl_ostream& operator<<(vcl_ostream& os, const Fred& fred)
@{
  os<<"Fred: "<<vcl_endl;
  vsl_indent_inc(os);
  fred.print(os);
  vsl_indent_dec(os);
  return os;
@}


class Jim
@{
private:
  Fred fred_;
public:
  void print(vcl_ostream& os) const
  @{
     os<<vsl_indent()<<fred_<<vcl_endl;
     os<<vsl_indent()<<"Jim's other data";
  @}
@};

vcl_ostream& operator<<(vcl_ostream& os, const Jim& jim)
@{
  os<<"Jim: "<<vcl_endl;
  vsl_indent_inc(os);
  jim.print(os);
  vsl_indent_dec(os);
  return os;
@}

main()
@{
  Jim jim;
  vcl_cout<<jim<<vcl_endl;
@}
@end example

This produces output:
@example
 Jim:
   Fred's data
   Jim's other data
@end example

If Jim were then included as a member of another class, Harry, one could get
output of the form
@example
Harry:
   Harry's basic data
   jim1:
     Fred's data
     Jim's other data
   jim2:
     Fred's data
     Jim's other data
@end example

and so forth.  The author humbly suggests that this makes the summaries
quite readable.

@section Error Detection
IO is often prone to errors beyond the control of the programmer. In
particular, files can be come corrupted, given to programs that can't read
a new format, read on platforms that do not support large enough numbers.

vsl attempts to detect as many error conditions as possible.
It prints an error message to @code{vcl_cerr} and sets the fail bit
on the input stream. Any objects that were being loaded when the error
occurred should be consistent at least as far as being able to delete the
object safely.

During the opening of a binary input stream, vsl also checks
for a schema version number, and magic number that confirm that
the stream was written by vsl.

It is easy to detect the error condition as the example shows
@example
  vsl_b_ifstream bfs_in(path);
  if (!bfs_in)
  @{
    vcl_cout << "Could not open " << path
             << " for reading as binary IO" << vcl_endl;
    return;
  @}
  vsl_b_read(bfs_in, my_obj);
  if (!bfs_in)
  @{
    vcl_cout << "Unable to read my_obj" << vcl_endl;
    return;
  @}
  bfs_in.close();
@end example


@section Binary IO Design Notes (Developer Topic)
The aim of the binary IO is to provide a consistent mechanism for saving and
restoring all VXL objects to streams/files, in a cross platform manner.


@subsection Structure

The original intention was that ALL classes with data should implement
@code{b_write(os)} and @code{b_read(is)} as member functions, and that
the external @code{vsl_b_write(os,object);} would be implemented using
the member function.  The advantages of this scheme are that

@itemize @bullet
@item Member functions can save all the state of a class without making everything public
@item Keeping the IO in the class makes it more likely that it will be kept up to date
@end itemize

Unfortunately a problem arises with templated containers, such as @code{vbl_array_2d<T>}.
Creating a container of type T requires that @code{vsl_b_write(os,T)} is implemented,
otherwise the @code{b_write} for the array will not compile.  This means that
adding such code to the library would break existing code, and force un-necessary
implementation of reading/writing functions (even when creating arrays of
objects which are unlikely ever to be saved, such as GUI Widgets).

A related problem is that to keep the core libraries independent, one would have
to duplicate the basic binary IO of built in types in every library.  When templating
over a class outside the library, one might have to write a specialisation of the IO
functions to get them to compile.

The simplest solution is to write the code as `clip-on' libraries, as has been done.

However, for level-2 libraries, in general, neither of these problems will arise.
In this case it is strongly recommended by the authors that IO be built into the
class.


@subsection Format of Fundamental types

All values are stored in little endian format (as used by Intel and DEC
alpha processors.) We had to choose one, and we mostly use Intel platforms.

@subsubsection Format of Integer types

The original code from which @code{vsl} was derived was cross platform only in the sense
that it worked on either big-endian 32-bit platforms or little-endian 32-bit platforms.
This was not an unreasonable assumption at the time it was written. However during the
requirements capture for @code{vsl}, it became clear that being able to handle 64-bit
fundamental types would be necessary. For example the long on an alpha-64 is 64 bits.

It is fundamentally impracticable to deal quietly and correctly with the problems this
causes. In particular, a number greater than 4G can be represent by a 64-bit long. It
can be successfully saved, but a platform with a 32-bit long simply cannot represent
the value. Nevertheless it is necessary to deal with the problems in a predictable manner.
There were several options.

@enumerate
@item Fix the size of the various types.
@item Record the size of the various types in a header at the start of the file, and then
save values in native type.
@item Use an encoding scheme which works for any size.
@end enumerate

The first option has the advantage of being the simplest (on the platform which matches
the sizes chosen.) It has the disadvantage of either being twice as large as required on
some platforms, and not able to represent the full range of values on others.

The second option, has the advantages of doing the correct thing on all platforms,
and being very efficient when files are loaded and
saved on the same platform. This is especially true if the endian-ness was also flagged
in the header and values saved in native format. The disadvantage is that the code for
reading files on each platform must know about every other possibility. So if there are
@math{n} platforms supported, the numbers of options that need to be programmed is
@math{n^2}.

The third option, suggested by Peter Vanroose, has the advantage that it does the correct
thing on all platforms. Also, there is only one format,
and so the amount of code to write only grows linearly with the number of platforms rather
than quadratically as in option 2. The final
advantage is that the store file will likely be smaller, since numbers are represented
in as few bytes as possible. It has
the disadvantage of some extra computation and memory overhead when both reading and writing.


The performance of the encoding and decoding required for option 3 was measured.
On an Intel Pentium 3, using MSVC 6.0 in full optimisation mode,
25 million integers were encoded or decoded at once.
The results do not include memory allocation overhead but does include some OS overhead.

@example
Type     Range of values  Range of encoded size  Encoding time   Decoding time
                                 / bytes         /clock cycles   /clock cycles
unsigned    0  -> 127             1                  18              24
int        -64 ->  63             1                  19              28
unsigned    0  ->  4G     1,2,3,4,but mostly 5       37              95
int        -2G ->  2G     1,2,3,4,but mostly 5       47             105
@end example

This means that a 850 Mhz PC can encode about 50 million small valued integers per
second, and decode about 35 million. The decoding takes longer due to the need for testing
for integer overflow.

We consider these speeds to be fast enough. and so option 3 was chosen.

The arbitrary length format stores the number in a series of bytes. Of each byte, 7 bits
are used to represent the number and the most significant bit is used to flag the end of the number.
The flag bit is 0 if there
are more bytes left for this integer, and 1 if this is the last byte. The bytes are stored
in little endian order, and the signed numbers are stored using 2s complement notation.

A consequence of this choice is that for example a number can be written from a short, and read
into a long. We strongly advise against doing this, as it relies on the implementation details.

@subsubsection Format of Floating Point Types

Since almost all platforms use IEEE format floating point types to represent floats
and doubles, we have used this format (in little endian order) to save them to disk.

A downside of this decision is that it is unclear how to store long doubles. The 80bit format
that is native to Intel platforms would not appear to be sufficiently general.
The best alternative would be to switch to variable length encoded floating point values.
It might be easier just to design a 128 bit format. Until then I/O of long doubles is not
supported. Please contact the designers if you need to add it.


@subsection Changing the IO format

The @code{vsl} system stores a IO schema version number at the start of the stream. This will enable
a clean backwards compatible upgrade of the IO schema. It will not however make the rewrite of
@code{vsl} trivial. Contact the designers if you wish to change the schema.

@subsection File Magic Numbers

If you use Unix, the following can be inserted in your /etc/magic file so that the @command{file} command
will recognise @code{vsl} files.

@example
#------------------------------------------------------------------------------
# VXL: file(1) magic for VXL binary IO data files
#
# from Ian Scott <scottim@sf.net>
#
# VXL is a collection of C++ libraries for Computer Vision.
# See the vsl chapter in the VXL Book for more info
# http://www.isbe.man.ac.uk/public_vxl_doc/books/vxl/book.html
# http:/vxl.sf.net

2       lelong  0x472b2c4e      VXL binary file,
>0      leshort >0      schema version no %d

@end example

@subsection Serialisation

A common approach to performing serialisation, is to store the serial number in the shared object
itself. This is the approach used by the Microsoft Foundation Classes, and by DEX (the IUE's IO
and serialisation scheme.)

There are two disadvantages to this. The first is that you have to modify
the object being serialised.

The second is that this scheme can get confused if a set of objects
is being written to two streams. When do you clear the already saved flag for each object?
What happens if the output to the two streams is being interleaved? Will a shared object get
saved to one stream and not the other?

A different approach is used by @code{vsl}. Here the serialisation record is kept by the stream object.
Pointers are used to uniquely identify each shared object within each computer, and a serial number
is generated to be saved on the stream. Since there is now a record for each pair
(stream, shared object) there will not be any clashes when saving to multiple streams. It also
avoids having to modify the shared object.


@subsection Future Work

@enumerate
@item Currently, a few error checks in the IO still result in a error message and @code{abort()}. Since
IO code is error prone for reasons often beyond the control of the programmer, this behaviour should be
replaced with a standard error message a setting of the stream's fail flag, and return.
@item Design a format for @code{long double} and add it @code{to vsl_binary_io.h}.
@item Many of the function and file names do not conform to VXL standards - that each
function and class should be named after the file-stem that declares and defines it.
@end enumerate

@section Loading by baseclass pointer: Design Overview (Advanced Topic)

When using polymorphism, there are frequently times when one needs to
save and restore an object just using a base class pointer to it.
@code{vsl} provides facilities to do this.

There are two cases to consider
@itemize @bullet
@item IO is provided by the class itself
@item IO is provided by external `clip-on' classes.
@end itemize

The former is the preferred method.

The latter is provided to allow binary IO for third-party libraries which cannot be
modified.  However, for technical reasons (see design notes below) it is also
used to provide binary IO for the polymorphic hierarchies in the VXL core
libraries.

@subsection IO provided within the class

@example
#include <vsl/vsl_binary_loader.h>

class vxl_my_class : public vxl_baseclass
@{
// ...
  virtual void b_write(vsl_b_ostream&) const;
  virtual void b_read(vsl_b_ostream&);
  virtual vcl_string is_a() const;
  virtual bool is_class(vcl_string const&) const;
  virtual vxl_baseclass* clone() const;
@};

//: Provide examples of each type of polymorphic object
//  that might appear in the stream.
void vxl_configure_loaders()
@{
    vsl_add_to_binary_loader(vxl_my_class());
@}

void demonstrate_save(vsl_b_ostream& os)
@{
    vxl_baseclass *base_ptr = new vxl_my_class;

    // Write the object to the stream, together with
    // an identifier indicating what type it is.
    vsl_b_write(os,base_ptr);

    // Tidy up
    delete base_ptr;
@}


void demonstrate_load(vsl_b_istream& is)
@{
    vxl_baseclass *base_ptr

    vsl_b_read(is,base_ptr);

    // Show the object
    vcl_cout<<"Loaded object: "<<base_ptr<<vcl_endl;

    // Tidy up
    delete base_ptr;
@}
@end example

@subsubsection How loading by baseclass pointer works (in-class case)
When an object is saved by baseclass pointer, using @code{vsl_b_write(os,const baseclass*)},
the name of the class is written first, then the object itself.

When one comes to load the object, using @code{vsl_b_read(is,baseclass* &)}, the following
occurs:

@enumerate
@item The singleton loader object (@code{vsl_binary_loader<baseclass>}) is invoked.
@item The loader reads the name of the class from the stream.
@item The loader compares this name with a list of possible objects,
      which have been supplied by earlier calls to @code{vsl_add_to_loader(derived_class())}.
@item If the loader finds a match, it creates a clone of the named class object.
@item This clone loads the data from the stream.
@item The loader then sets the baseclass pointer to point to this new object.
@end enumerate

So you now have a shiny pointer to the object. Note: The caller is then responsible
for the object that the loader created.

The above methods also work if the
pointer that was saved was NULL.  The loader will detect this and set the baseclass
pointer to zero.

@subsection IO provided by external `clip-on' classes

@example
class vxl_my_class : public vxl_baseclass
@{
// ...
  // No IO here
@};

//: Provide IO for vxl_my_class
class vxl_my_class : public vxl_baseclassIO @{
public:
  //: Constructor
  vxl_my_classIO();

  //: Destructor
  virtual ~vxl_my_classIO();

  //: Create new object of type vxl_my_class on heap
  virtual vxl_baseclass* new_object() const;

  //: Write derived class to os using baseclass reference
  virtual void b_write_by_base(vsl_b_ostream& os, const vxl_baseclass& base) const;

   //: Write derived class to os using baseclass reference
  virtual void b_read_by_base(vsl_b_istream& is, vxl_baseclass& base) const;

    //: Copy this object onto the heap and return a pointer
  virtual vxl_baseclassIO* clone() const;

   //: Return name of class for which this object provides IO
  virtual vcl_string target_classname() const;

    //: Return true if b is of class target_classname()
    //  Typically this will just be "return b.is_class(target_classname())"
    //  However, third party libraries may use a different system
  virtual bool is_io_for(const vxl_baseclass& b) const;
@};


//: Provide IO class for each type of polymorphic object
// that might appear in the stream.
void vxl_configure_loaders()
@{
    vsl_add_to_binary_loader(vxl_my_class_io());
@}

// The actual IO calls are then identical to those described above for the
// case of the IO provided within the class

@end example

See below for details of the implementation of the clip-on IO libraries.

@subsection How loading by baseclass pointer works (external IO case)

Essentially this is similar to the within-class-IO case, in that a string
is written to the stream to indicate which class is saved, and when reading
the stream this is used to indicate what to generate on the heap.
However, the details of the implementation are more complicated.

When an object is saved by baseclass pointer, using @code{vsl_b_write(os,const baseclass*)},
a function in @code{vsl_clipon_binary_loader<baseclass,baseclass_io>} is invoked.
It contains a list of IO objects, each of which is queried
(using the @code{io.is_io_for(const baseclass&)} function to see if it can deal with the
given class.  If so a name, @code{io.target_classname()}, is saved to the stream, then the
IO object is used to save the target object.

When one comes to load the object, using @code{vsl_b_read(is,baseclass* &)}, the following
occurs:

@enumerate
@item The singleton loader object (@code{vsl_clipon_binary_loader<baseclass,baseclass_io>}) is invoked.
@item The loader reads the name of the class from the stream.
@item The loader compares this name with a list of possible objects,
      which have been supplied by earlier calls to @code{vsl_add_to_loader(derived_class())}.
@item If the loader finds a match, it uses the IO object to create a new object on the heap
@item The io object then loads the data from the stream into the object on the heap
@item The loader then sets the baseclass pointer to point to this new object.
@end enumerate

So you now have a shiny pointer to the object. Note: The caller is then responsible
for the object that the loader created.

The above methods also work if the
pointer that was saved was NULL.  The loader will detect this and set the baseclass
pointer to zero.

@section Adding Binary I/O to a New Class (Developer Topic)

The golden rule for trouble free binary IO is
@quotation
Always write the input and output code in tandem - the output should
precisely mirror the input.
@end quotation

First you need to evaluate whether the class needs binary I/O.
For example, the @code{vnl_matrix_ref} can just be left to inherit from
@code{vnl_matrix} because it does not have any additional member
variables.
Often iterators tend to be transient things which should not be
saved.

Where one does wish to save state, there are four cases to consider:
@enumerate
@item The class is a non-polymorphic (plain) class with no virtual functions
@item The class is a base class with virtual functions
@item The class is a derived class with virtual functions
@item The class is derived from a plain class but is not strictly polymorphic,
      and has no virtual functions
@end enumerate

The last must be considered because various classes in vxl are derived
from plain classes.  The base classes in these cases are kept as
plain classes to improve memory efficiency.


@subsection Non-polymorphic (Plain) Classes
For plain classes (those with no virtual functions), and those derived from plain classes,
you need to add the following functions to the class definition in the .h file.
@example
//: Binary save self to stream.
  void b_write(vsl_b_ostream &os) const;

  //: Binary load self from stream.
  void b_read(vsl_b_istream &is);

  //: Return IO version number;
  short version() const;

  //: Print an ascii summary to the stream
  void print_summary(vcl_ostream &os) const;

  //: Return a platform independent string identifying the class
  vcl_string is_a() const;

  //: Return true if the argument matches the string identifying the class or any parent class
  bool is_class(vcl_string const&) const;

@end example
You will also need to add the following global scope helper function
declarations to the .h file

@example
//: Binary save vnl_my_class to stream.
void vsl_b_write(vsl_b_ostream &os, const vnl_my_class & b);

//: Binary load vnl_my_class from stream.
void vsl_b_read(vsl_b_istream &is, vnl_my_class & b);
@end example

NOTE: YOU SHOULD ALSO ADD APPROPRIATE TEST PROGRAMS : See below


@subsection Base Classes
For base classes (those classes at the base of a polymorphic hierarchy, with virtual functions),
you need to add the following functions to the class definition in the .h file.

@example
  //: Binary save self to stream.
  virtual void b_write(vsl_b_ostream &os) const;

  //: Binary load self from stream.
  virtual void b_read(vsl_b_istream &is);

  //: Return IO version number;
  short version() const;

  //: Print an ascii summary to the stream
  virtual void print_summary(vcl_ostream &os) const;

  //: Return a platform independent string identifying the class
  virtual vcl_string is_a() const=0;

  //: Return true if the argument matches the string identifying the class
  virtual bool is_class(vcl_string const&) const;

  //: Create a copy of the object on the heap.
  // The caller is responsible for deletion
  virtual vanyl_my_base_class* clone() const=0;

@end example
You will also need to add the following global scope helper function declarations to the .h file

@example
    //: Binary save vnl_my_class to stream.
  void vsl_b_write(vsl_b_ostream &os, const vnl_my_class & b);

    //: Binary load vnl_my_class from stream.
  void vsl_b_read(vsl_b_istream &is, vnl_my_class & b);

    //: Allows derived class to be loaded by base-class pointer
    //  A loader object exists which is invoked by calls
    //  of the form "vsl_b_read(os,base_ptr)".  This loads derived class
    //  objects from the disk, places them on the heap and
    //  returns a base class pointer.
    //  In order to work the loader object requires
    //  an instance of each derived class that might be
    //  found.  This function gives the model class to
    //  the appropriate loader.
  void vsl_add_to_binary_loader(const vanyl_my_base_class& b);

    //: Stream output operator for class pointer
  void vsl_print_summary(vcl_ostream& os,const vanyl_my_base_class* b);
@end example

NOTE: YOU SHOULD ALSO ADD APPROPRIATE TEST PROGRAMS : See below


@subsection Derived Classes
For derived classes in a polymorphic hierarchy, which include virtual functions,
you need to add the following functions to the class definition in the .h file.

@example
  //: Binary save self to stream.
  virtual void b_write(vsl_b_ostream &os) const;

  //: Binary load self from stream.
  virtual void b_read(vsl_b_istream &is);

  //: Return IO version number;
  short version() const;

  //: Print an ascii summary to the stream
  virtual void print_summary(vcl_ostream &os) const;

  //: Return a platform independent string identifying the class
  virtual vcl_string is_a() const;

  //: Return true if the argument matches the string identifying the class or any parent class
  bool is_class(vcl_string const&) const;

  //: Create a copy of the object on the heap.
  // The caller is responsible for deletion
  virtual vanyl_my_base_class* clone() const;

@end example

In this case you should not need any global helper functions, as they
are included in the base class.


NOTE: YOU SHOULD ALSO ADD APPROPRIATE TEST PROGRAMS : See below


@subsection The Implementation Code to Add

The following is a template for the standard code for the implementation of each of the
methods and functions declared above.


@subsubsection Version Numbering
This identifies the I/O version numbering. It needs to be incremented when the
class's binary I/O changes.

There is no reason why this version number can't be
used for other purposes. So long as the @code{b_read()} method is updated to deal with it.

It is common and perfectly acceptable to modify a classes I/O during very early development without
changing the version number.

@example
//=======================================
//: Return IO version number;
short vanyl_my_class::version() const
@{
  return 1;
@}
@end example

@subsubsection Saving Binary State to a Stream
Classes should first save their version number. Derived classes should then
call the base class @code{b_write()}, if the base class has any data members.
Finally write the classes data members.

If data is duplicated within the class,
(e.g. some workspace data) you will have to decide whether to save and reload the data,
or else not save it  and regenerate it on loading.

The standard form for the method is
@example
//=======================================
//: Binary save self to stream.
void vanyl_my_class::b_write(vsl_b_ostream &os) const
@{
  vsl_b_write(os, version());
  vanyl_my_base_class::b_write(os); // vanyl_my_base_class is parent of vanyl_my_class
  vsl_b_write(os, this->my_value);
  ...
@}
@end example

@subsubsection Restoring Binary State from a Stream

This function is less complicated than it looks. The complexity of the switch statement is there
solely to give as much backwards compatibility as you are willing to program.

@example
//=======================================
//: Binary load self from stream.
void vanyl_my_class::b_read(vsl_b_istream &is)
@{
  if (!is) return;

  short ver;
  vsl_b_read(is, ver);
  switch(ver)
  @{
  case 1:
    vanyl_my_base_class::b_read(is); // vanyl_my_base_class is parent of vanyl_my_class
    vsl_b_read(is, this->my_value);
    ...
  break;

  default:
    vcl_cerr << "I/O ERROR: vanyl_my_class::b_read(vsl_b_istream&) \n";
    vcl_cerr << "           Unknown version number "<< ver << "\n";
    is.is().clear(vcl_ios::badbit); // Set an unrecoverable IO error on stream
    return;
  @}
@}
@end example

@subsubsection Print a Human Readable Summary to a Stream
Classes should print a short summary of their contents. Devolve printing
of complex members and parent classes to that class, only if it is sensible.

Do not give too much information. For instance if your class is a
container print the number of elements , and then no more than
perhaps the first 5 elements, with ellipsis to indicate if there
are more.

To aid clear printing the following rule has been found to be helpful.
@quotation
If a summary can be printed on a single line, then do not output a linefeed.
If a summary contains linefeeds in the middle, then finish the summary with a linefeed.
@end quotation
This approach gives flexibility in the output format whilst preserving readability
and predictability for programmers.

The standard form for the method is
@example
//=======================================
//: Output a human readable summary to the stream
void vanyl_my_class::print_summary(vcl_ostream &os) const
@{
    os<<"Important Value: "<<this->my_value<<" .. ";
    ...
    // optionally os << vcl_endl;
@}
@end example


@subsubsection Platform Independent Class Identification

Unfortunately neither the @code{type_info} class nor the @code{type_info::name} field given
by RTTI are platform independent. To allow loading of a class by base class
pointer, the @code{is_a()}
method is used to identify exactly which
object to create. It can also be used for other purposes.

If the class is not part of an inheritance hierarchy or will not ever be loaded by base class
pointer, the @code{is_a()} method is not necessary and can be left out.

@example
//=======================================
//: Return a platform independent string identifying the class
vcl_string vanyl_my_class::is_a() const
@{
    return vcl_string("vanyl_my_class");
@}
@end example

The @code{is_class()} methods are not used by the vsl system, but are useful when
you don't have RTTI.
@example
//=======================================
//: Return true if the argument matches the string identifying the class or any parent class
bool vanyl_my_class::is_class(vcl_string const& s) const
@{
    return s==vanyl_my_class::is_class || vanyl_parent_class::is_class(s);
@}
@end example


@subsubsection Polymorphic Copy Creation onto the Heap

The base class loader scheme needs to be able to create a new object on the heap
from a base_class pointer to an old one. If the class is not part of an inheritance
hierarchy or will not ever be loaded by base class
pointer, the @code{clone()} method is not necessary and can be left out.

The code below assumes that either a working copy constructor has been defined, or else
that compiler generated default copy constructor is suitable(e.g. The class has no pointer
or reference member variables.)

@example
//=======================================
//: Create a copy of the object on the heap.
// The caller is responsible for deletion
vanyl_my_base_class* vanyl_my_class::clone() const
@{
  return new vanyl_my_class(*this);
@}
@end example

@subsubsection Helper Functions.


@example
//==============================================
//: Binary save vnl_vector to stream.
void vsl_b_write(vsl_b_ostream &os, const vanyl_my_class & v)
@{
  v.b_write(os);
@}

//==============================================
//: Binary load vnl_vector from stream.
void vsl_b_read(vsl_b_istream &is, vanyl_my_class & v)
@{
  v.b_read(is);
@}
@end example
It is acceptable to inline the previous two functions, in which case a half-decent compiler
will optimise them completely away.

@example
//==============================================
//: Output a human readable summary to the stream
void vsl_print_summary(vcl_ostream& os,const vanyl_my_class& v)
@{
  os << v.is_a() << ": ";
  vsl_indent_inc(os);
  v.print_summary(os);
  vsl_indent_dec(os);
@}

@end example

@subsubsection Base Classes

The implementation code for functions to be added to base classes is as follows

@example
//==============================================
//: Allows derived class to be loaded by base-class pointer
//  A loader object exists which is invoked by calls
//  of the form "vsl_b_read(os,base_ptr);".  This loads derived class
//  objects from the stream, places them on the heap and
//  returns a base class pointer.
//  In order to work the loader object requires
//  an instance of each derived class that might be
//  found.  This function gives the model class to
//  the appropriate loader.
void vsl_add_to_binary_loader(const vanyl_my_base_class& b)
@{
  vsl_binary_loader<vanyl_my_base_class>::instance().append(b);
@}

//==============================================
//: Stream summary output for base class pointer
void vsl_print_summary(vcl_ostream& os,const vanyl_my_base_class* b)
@{
    if (b)
        return vsl_print_summary(*b);
    else
        return os << "No vanyl_my_base_class defined.";
@}
@end example


If the base class is abstract, then you should not to provide
implementations for the following methods. Instead declare them
as pure virtual methods in the .h file.
@example
        //: Create a copy on the heap and return base class pointer
    virtual my_base_class* clone() const = 0;

        //: Print class to os
    virtual void print_summary(vcl_ostream& os) const = 0;

        //: Save class to binary file stream
    virtual void b_write(vsl_b_ostream& bfs) const = 0;

         //: Load class from binary file stream
    virtual void b_read(vsl_b_istream& bfs) = 0;

@end example


@subsection Serialisation - Saving Objects with Shared Ownership

There is problem when you want to save an object whose ownership is shared by
several other objects. The most common way this happens is if several objects
(A1, A2, ..., An) contain pointers to a single other object B. If all the objects save B,
when the stream is reloaded, there wile be n copies of B in memory, instead of the
single shared one there was before saving.

If one object can be designated the @emph{owner} (for example if one object, say A1,
is responsible for deleting B,) then A1 is responsible for saving and loading
object B. This prevents multiple copies of B being created during loading, but all the
other A objects do not have their pointer set up correctly.

The standard way of dealing with these problems involves giving each shared object a unique
@dfn{serial number}, and the process of performing IO on shared objects is called
@dfn{serialisation}.

If you are using shared objects though existing classes such as @code{vbl_smart_ptr}, or
@code{vil_image}, then you do not need to do anything, since these classes handle the
serialisation.

If you are managing shared ownership in any of your classes, you will need to write
the serialising code yourself. There is no language support for serialisation in C++
(unlike Java), however the @code{vsl} library does provide some support.

The basic algorithm performed by all of the owner objects during saving is
@itemize @bullet
@item If object B has not been saved before
  @itemize @bullet
  @item generate a unique serial number for object B
  @item save the serial number
  @item save object B
  @end itemize
@item else if we have already saved B
  @itemize @bullet
  @item find unique serial number for object B
  @item save the serial number
  @end itemize
@item end
@end itemize

The basic algorithm performed by all of the owner objects during loading is
@itemize @bullet
@item load unique serial number
@item if this is the first time we have seen this serial number
  @itemize @bullet
  @item load object B
  @item set my pointer to point to B
  @end itemize
@item else if we have seen the serial number before
  @itemize @bullet
  @item find location in memory of object B with given serial number
  @item set my pointer to point to B
  @end itemize
@item end
@end itemize

You can use the serialisation record in @code{vsl_b_istream} and
@code{vsl_b_ostream} to record the serial numbers, and whether
you have already saved object B.

The best way to explain the detail is in this simplified and
cut-down version of @file{vxl/vbl/io/vbl_io_smart_ptr.txx}
In this case all the smart_ptr<T> objects are the As, and the
objects they point to are the Bs.

@example
#include <vsl/vsl_binary_io.h>
#include <vbl/vbl_smart_ptr.h>

//: Binary save smart_ptr and serialised *smart_ptr to stream.
template<class T>
void vsl_b_write(vsl_b_ostream & os, const vbl_smart_ptr<T> &p)
@{

  // write version number
  const short io_version_no = 1;
  vsl_b_write(os, io_version_no);

  // Get a serial_number for object being pointed to
  unsigned long id = os.get_serial_number(p.ptr());

  // Find out if this is the first time the object being
  // pointed to is being saved
  if (id == 0)
  @{

    // Store a record of the address of B and get a serial number
    id = os.add_serialisation_record(p.ptr());

    vsl_b_write(os, id);     // Save the serial number

// If you get a compiler error in the next line, it could be because your type T
// has no vsl_b_write(vsl_b_ostream &,const T*)  defined on it.
// See the documentation in the .h file to see how to add it.
    vsl_b_write(os, p.ptr());  // Only save the actual object if
                                // it hasn't been saved before to this stream
  @}
  else
  @{
    vsl_b_write(os, id);         // Save the serial number
  @}

@}

//=============================================================================
//: Binary load self from stream.
template<class T>
void vsl_b_read(vsl_b_istream &is, vbl_smart_ptr<T> &p)
@{
  short ver;
  vsl_b_read(is, ver);
  switch(ver)
  @{
  case 1:
    @{
      unsigned long id; // Unique serial number identifying object
      vsl_b_read(is, id);

      T * pointer = (T *) is.get_serialisation_pointer(id);
      if (pointer == 0) // Not loaded before
      @{
// If you get a compiler error in the next line, it could be because your type T
// has no vsl_b_read(vsl_b_ostream&,T*&)  defined on it.
// See the documentation in the .h file to see how to add it.
        vsl_b_read(is, pointer);                 // load object B
        is.add_serialisation_record(id, pointer); // remember location of B
      @}

      p.set_ptr(pointer); // This operator method will set the internal
                          // pointer in vbl_smart_ptr.
    @}
    break;
  default:
    vcl_cerr << "vbl_smart_ptr::b_read() Unknown version number "
             << ver << vcl_endl;
    vcl_abort();
  @}
@}
@end example

You do not need to write any special code for the owned object, except
to provide member functions for loading and saving the object by
pointer. These will already exist if you have written polymorphic IO
for the class of object B. If not, the following examples might help.

@example
// Save with base class pointers
void vsl_b_read(vsl_b_istream& is, class_B * &p)
@{
  delete p;
  bool not_null_ptr;
  vsl_b_read(is, not_null_ptr);
  if (not_null_ptr)
  @{
    p = new class_B;
    vsl_b_read(is, *p);
  @}
  else
    p = 0;
@}

template<class T>
void vsl_b_write(vsl_b_ostream& os, const class_B *p)
@{
  if (p==0)
  @{
    vsl_b_write(os, false); /* Indicate null pointer stored */
  @}
  else
  @{
    vsl_b_write(os,true); /* Indicate non-null pointer stored */
      vsl_b_write(os,*p);
  @}
@}
@end example

The upshot of this is that serialisation can be tricky, but not
necessarily difficult. You are advised to manage shored ownership
though smart pointers which will do all the serialisation (and
memory management) for you.

@section Adding Binary I/O to Level-1 Libraries (Developer Topic)

There are several reasons for doing slightly different things for
classes that are members of a level-1 library.
@enumerate
@item No level-one library can depend on any library except vcl.
@item We do not wish to `break' any existing code
@item There is a desire to keep the level 1 libraries small.  IO is available if required.
@end enumerate

Binary IO for the level-1 libraries (@code{vbl},@code{vil},@code{vgl},@code{vnl})
is implemented using
`clip-on' libraries, the code for which lives in `io' subdirectories of
each library.  Thus the code for the IO for @code{vnl_vector<T>} lives in
@file{vnl/io/vnl_io_vector.h/.txx}.  Binary IO for vcl containers is provided in
the library @code{vsl}.

The `clip-on' libraries provide a set of external functions and classes which
allow binary save and restore of the level 1 classes through their public
member functions.

Essentially this means writing the following functions for each class:

@example
  //: Binary save vnl_my_class to stream.
  void vsl_b_write(vsl_b_ostream &os, const vnl_my_class & c);

  //: Binary load vnl_my_class from stream.
  void vsl_b_read(vsl_b_istream &is, vnl_my_class & c);

    //: Stream output operator for class pointer
  void vsl_print_summary(vcl_ostream& os, const vnl_my_class& c);
@end example

Each one is written using only the public access functions of the class.

For instance, @code{vgl_point_2d} has binary IO as follows:

@example
#ifndef vgl_io_point_2d_h_
#define vgl_io_point_2d_h_
#ifdef __GNUC__
#pragma interface
#endif

// This is vxl/vgl/io/vgl_io_point_2d.h

//:
// \file
// \author Tim Cootes

#include <vgl/vgl_point_2d.h>
#include <vsl/vsl_binary_io.h>

//: Binary save vgl_point_2d to stream.
template <class T>
void vsl_b_write(vsl_b_ostream &os, const vgl_point_2d<T>& p);

//: Binary load vgl_point_2d from stream.
template <class T>
void vsl_b_read(vsl_b_istream &is, vgl_point_2d<T>& p);

//: Print human readable summary of a vgl_point_2d object to a stream
template <class T>
void vsl_print_summary(vcl_ostream& os,const vgl_point_2d<T>& p);
#endif // #ifndef vgl_io_point_2d_h_
@end example

The implementation is

@example
// This is vxl/vgl/vgl_io_point_2d.txx

#include <vgl/io/vgl_io_point_2d.h>
#include <vsl/vsl_binary_io.h>

//==============================================================================
//: Binary save vgl_point_2d to stream.
template<class T>
void vsl_b_write(vsl_b_ostream &os, const vgl_point_2d<T>& p)
@{
  vsl_b_write(os, p.version());
  vsl_b_write(os, v.x());
  vsl_b_write(os, v.y());
@}

//==============================================================================
//: Binary load vgl_point_2d from stream.
template<class T>
void vsl_b_read(vsl_b_istream &is, vgl_point_2d<T>& p)
@{
  if (!is) return;

  short w;
  vsl_b_read(is, w);
  switch(w)
  @{
  case 1:
    vsl_b_read(is, p.x());
    vsl_b_read(is, p.y());
    break;

  default:
    vcl_cerr << "I/O ERROR: vsl_b_read(vsl_b_istream&, vgl_point_2d<T>&) \n";
    vcl_cerr << "           Unknown version number "<< w << "\n";
    is.is().clear(vcl_ios::badbit); // Set an unrecoverable IO error on stream
    return;
  @}

@}


//==============================================================================
//: Output a human readable summary of a vgl_point_2d object to the stream
template<class T>
void vsl_print_summary(vcl_ostream &os, const vgl_point_2d<T>& p)
@{
    os<<"(";
    vsl_print_summary(p.x());
    os<<","
    vsl_print_summary(p.y());
    os<<")";
@}

#define VGL_IO_LINE_2D_INSTANTIATE(T) \
template void vsl_print_summary(vcl_ostream &, const vgl_point_2d<T >&); \
template void vsl_b_read(vsl_b_istream &, vgl_point_2d<T >&); \
template void vsl_b_write(vsl_b_ostream &, const vgl_point_2d<T >&)

@end example


@subsection `Clip-On' IO for Polymorphic Hierarchies

Here are some examples:

@subsubsection Clip-on IO BaseClass Header

Here is an example of a @file{BaseClassIO.h}

@example
#ifndef BaseClassIO_h_
#define BaseClassIO_h_
#ifdef __GNUC__
#pragma interface
#endif

// This is BaseClass.h
#include <vsl/vsl_binary_io.h>

// Predeclare classes
class BaseClass;

//:
// \file
// \author Tim Cootes

//: Base for objects which provide IO for classes derived from BaseClass
class BaseClassIO @{
public:
  //: Constructor
  BaseClassIO();

  //: Destructor
  virtual ~BaseClassIO();

  //: Create new object of type BaseClass on heap
  virtual BaseClass* new_object() const;

  //: Write derived class to os using baseclass reference
  virtual void b_write_by_base(vsl_b_ostream& os, const BaseClass& base) const;

   //: Write derived class to os using baseclass reference
  virtual void b_read_by_base(vsl_b_istream& is, BaseClass& base) const;

    //: Copy this object onto the heap and return a pointer
  virtual BaseClassIO* clone() const;

   //: Return name of class for which this object provides IO
  virtual vcl_string target_classname() const;

    //: Return true if b is of class target_classname()
    //  Typically this will just be "return b.is_class(target_classname())"
    //  However, third party libraries may use a different system
  virtual bool is_io_for(const BaseClass& b) const;
@};

//: Add example object to list of those that can be loaded
//  The vsl_binary_loader must see an example of each derived class
//  before it knows how to deal with them.
//  A clone is taken of b
void vsl_add_to_binary_loader(const BaseClassIO& b);

//: Binary save to stream by baseclass pointer
void vsl_b_write(vsl_b_ostream &os, const BaseClass * b);

//: Binary read from stream by baseclass pointer
void vsl_b_read(vsl_b_istream &is, BaseClass* &b);

//: Binary save vgl_my_class to stream.
void vsl_b_write(vsl_b_ostream &os, const BaseClass & b);

//: Binary load vgl_my_class from stream.
void vsl_b_read(vsl_b_istream &is, BaseClass & b);

//: Print human readable summary of object to a stream
void vsl_print_summary(vcl_ostream& os,const BaseClass & b);

@end example

@subsubsection Clip-on IO BaseClass Implementation

For a BaseClass, one creates @file{BaseClassIO.cxx} as follows

@example
#ifdef __GNUC__
#pragma implementation
#endif

// This is BaseClassIO.cxx
#include <BaseClass.h>
#include <BaseClassIO.h>
#include <vsl/vsl_clipon_binary_loader.txx>
//:
// \file
// \author Tim Cootes

//: Constructor
BaseClassIO()::BaseClassIO()
@{
@}

//: Destructor
BaseClassIO()::~BaseClassIO()
@{
@}

//: Create new object of type BaseClass on heap
BaseClass* BaseClassIO()::new_object() const
@{
  return new BaseClass;
@}

//: Write derived class to os using baseclass reference
void BaseClassIO()::b_write_by_base(vsl_b_ostream& os, const BaseClass& base) const
@{
  vsl_b_write(os,base);
@}

//: Write derived class to os using baseclass reference
void BaseClassIO()::b_read_by_base(vsl_b_istream& is, BaseClass& base) const
@{
  vsl_b_read(is,base);
@}


//: Copy this object onto the heap and return a pointer
BaseClassIO* BaseClassIO()::clone() const
@{
  return new BaseClassIO(*this);
@}

//: Return name of class for which this object provides IO
vcl_string BaseClassIO()::target_classname() const
@{
  return string("BaseClass");
@}

//: Return true if b is of class target_classname()
bool BaseClassIO()::is_io_for(const BaseClass& b) const
@{
  return (b.is_a()==target_classname());
@}

//====================================================================================
//: Binary write to stream.
void vsl_b_write(vsl_b_ostream &os, const BaseClass & p)
@{
  const short io_version_no = 1;
  vsl_b_write(os, io_version_no);
  vsl_b_write(os, p.x());
  vsl_b_write(os, p.y());
  ... Insert rest of xxxxxx code here
@}

//====================================================================================
//: Binary load from stream.
void vsl_b_read(vsl_b_istream &is, BaseClass & p)
@{
  if (!is) return;

  short v;
  vsl_b_read(is, v);
  switch(v)
  @{
  case 1:
    vsl_b_read(is, p.x());
    vsl_b_read(is, p.y());
    ... Insert rest of xxxxxx code here
    break;

  default:
    vcl_cerr << "I/O ERROR: vsl_b_read(vsl_b_istream&, BaseClass&) \n";
    vcl_cerr << "           Unknown version number "<< v << "\n";
    is.is().clear(vcl_ios::badbit); // Set an unrecoverable IO error on stream
    return;
  @}

@}


//====================================================================================
//: Output a human readable summary to the stream
void vsl_print_summary(vcl_ostream& os,const BaseClass & p)
@{
    os<<"("<<p.x()<<","<<p.y()<<")";
    ... Insert rest of xxxxxx code here
@}

//: Add example object to list of those that can be loaded
//  The vsl_binary_loader must see an example of each derived class
//  before it knows how to deal with them.
//  A clone is taken of b
void vsl_add_to_binary_loader(const BaseClassIO& b)
@{
    vsl_clipon_binary_loader<BaseClass,BaseClassIO>::instance().add(b);
@}


//: Binary save to stream by baseclass pointer
void vsl_b_write(vsl_b_ostream &os, const BaseClass * b)
@{
    vsl_clipon_binary_loader<BaseClass,BaseClassIO>::instance().write_object(os,b);
@}

//: Binary read from stream by baseclass pointer
void vsl_b_read(vsl_b_istream &is, BaseClass* &b)
@{
    vsl_clipon_binary_loader<BaseClass,BaseClassIO>::instance().read_object(is,b);
@}


// Explicitly instantiate loader
VSL_CLIPON_BINARY_LOADER_INSTANTIATE(BaseClass, BaseClassIO);


@end example

@subsubsection Clip-on IO Derived Class Header

For a DerivedClass, one creates DerivedClassIO header as follows

@example
#ifndef DerivedClassIO_h_
#define DerivedClassIO_h_
#ifdef __GNUC__
#pragma interface
#endif

// This is DerivedClassIO.h

//:
// \file
// \author Tim Cootes

#include <BaseClassIO.h>

class DerivedClass;

//: Provide IO for DerivedClass
class DerivedClass : public BaseClassIO @{
public:
  //: Constructor
  DerivedClassIO();

  //: Destructor
  virtual ~DerivedClassIO();

  //: Create new object of type DerivedClass on heap
  virtual BaseClass* new_object() const;

  //: Write derived class to os using baseclass reference
  virtual void b_write_by_base(vsl_b_ostream& os, const BaseClass& base) const;

   //: Write derived class to os using baseclass reference
  virtual void b_read_by_base(vsl_b_istream& is, BaseClass& base) const;

    //: Copy this object onto the heap and return a pointer
  virtual BaseClassIO* clone() const;

   //: Return name of class for which this object provides IO
  virtual vcl_string target_classname() const;

    //: Return true if b is of class target_classname()
    //  Typically this will just be "return b.is_class(target_classname())"
    //  However, third party libraries may use a different system
  virtual bool is_io_for(const BaseClass& b) const;
@};

//: Binary save vgl_my_class to stream.
void vsl_b_write(vsl_b_ostream &os, const DerivedClass & b);

//: Binary load vgl_my_class from stream.
void vsl_b_read(vsl_b_istream &is, DerivedClass & b);

//: Print human readable summary of object to a stream
void vsl_print_summary(vcl_ostream& os, const DerivedClass & b);

@end example

@subsubsection Clip-on IO Derived Class Implementation

For a DerivedClass, one creates @file{DerivedClassIO.cxx} as follows

@example
#ifdef __GNUC__
#pragma implementation
#endif

// This is DerivedClassIO.cxx

#include <DerivedClass.h>
#include <DerivedClassIO.h>

//:
// \file
// \author Tim Cootes

//: Constructor
DerivedClassIO()::DerivedClassIO()
@{
@}

//: Destructor
DerivedClassIO()::~DerivedClassIO()
@{
@}

//: Create new object of type DerivedClass on heap
BaseClass* DerivedClassIO()::new_object() const
@{
  return new DerivedClass;
@}

//: Write derived class to os using baseclass reference
void DerivedClassIO()::b_write_by_base(vsl_b_ostream& os, const BaseClass& base) const
@{
  vsl_b_write(os,base);
@}

//: Write derived class to os using baseclass reference
void DerivedClassIO()::b_read_by_base(vsl_b_istream& is, BaseClass& base) const
@{
  vsl_b_read(is,base);
@}


//: Copy this object onto the heap and return a pointer
BaseClassIO* DerivedClassIO()::clone() const
@{
  return new DerivedClassIO(*this);
@}

//: Return name of class for which this object provides IO
vcl_string DerivedClassIO()::target_classname() const
@{
  return vcl_string("DerivedClass");
@}

//: Return true if b is of class target_classname()
bool DerivedClassIO()::is_io_for(const BaseClass& b) const
@{
  return (b.is_a()==target_classname());
@}

//====================================================================================
//: Binary write to stream.
void vsl_b_write(vsl_b_ostream &os, const DerivedClass & p)
@{
  const short io_version_no = 1;
  vsl_b_write(os, io_version_no);
  vsl_b_write(os, p.x());
  vsl_b_write(os, p.y());
  ... Insert rest of xxxxxx code here
@}

//====================================================================================
//: Binary load from stream.
void vsl_b_read(vsl_b_istream &is, DerivedClass & p)
@{
  if (!is) return;

  short v;
  vsl_b_read(is, v);
  switch(v)
  @{
  case 1:
    vsl_b_read(is, p.x());
    vsl_b_read(is, p.y());
    ... Insert rest of xxxxxx code here
    break;

  default:
    vcl_cerr << "I/O ERROR: vsl_b_read(vsl_b_istream&, DerivedClass&) \n";
    vcl_cerr << "           Unknown version number "<< v << "\n";
    is.is().clear(vcl_ios::badbit); // Set an unrecoverable IO error on stream
    return;
  @}

@}

@end example

There.  Nothing to it really.

@section Test Programs (Developer Topic)

It is important to write test programs for all the IO.  Below is a
summary of how it is done for classes in vgl.  Extrapolate as
appropriate.

The test programs for vgl live in the subdirectory vgl/tests.

To add a test for a class you

@enumerate
@item Write a test function in a file : @file{test_classname_io.cxx}
@item Add a call to that function in the file @file{vgl_test_io.cxx}
@end enumerate

For instance, to test the IO in class @code{vgl_point_2d<T>}, we
write

@file{test_point_2d_io.cxx}:
@example
#include <vcl_iostream.h>
#include <vcl_fstream.h>
#include <vcl_utility.h>

#include <vgl/vgl_test.h>
#include <vgl/io/vgl_io/point_2d.h>

void test_point_2d_double_io()
@{
    vcl_cout << "***********************" << vcl_endl;
    vcl_cout << "Testing vgl_point_2d<double> io" << vcl_endl;
    vcl_cout << "***********************" << vcl_endl;

    vgl_point_2d<double> p_out(1.2,3.4), p_in;


    vsl_b_ofstream bfs_out("vgl_point_2d_test_double_io.bvl.tmp");
    TEST ("Created vgl_point_2d_test_double_io.bvl.tmp for writing", (!bfs_out), false);
    vsl_b_write(bfs_out, p_out);
    bfs_out.close();

    vsl_b_ifstream bfs_in("vgl_point_2d_test_double_io.bvl.tmp");
    TEST ("Opened vgl_point_2d_test_double_io.bvl.tmp for reading", (!bfs_in), false);
    vsl_b_read(bfs_in, p_in);
    TEST ("Finished reading file successfully", (!bfs_in), false);
    bfs_in.close();


    TEST ("p_out == p_in", p_out == p_in, true);


    vsl_print_summary(vcl_cout, p_out);
        vcl_cout << vcl_endl;

@}

void test_point_2d_prime()
@{
    // Test each template type
    test_point_2d_double_io();
@}

TESTMAIN(test_point_2d_prime);
@end example

The macros @code{TEST} and @code{TESTMAIN} are defined in the file @file{vgl/vgl_test.h}

We must then add a call to this test to @file{test_vgl_io.cxx}:

@example
#include <vgl/vgl_test.h>
#undef TESTMAIN
#define TESTMAIN(x)
#include <vgl/tests/test_point_2d_io.cxx>
#include <vgl/tests/test_point_3d_io.cxx>

#undef TESTMAIN
#define TESTMAIN(x) int main() @{ vgl_test_start(#x); x(); return vgl_test_summary(); @}

void run_test_vgl_io()
@{
  test_point_2d_double_io();
  test_point_3d_double_io();
  // More tests ....
@}

TESTMAIN(run_test_vgl_io);
@end example

When one runs make (under Unix) all the programs are compiled and the
tests automatically run.  A message will be output giving a summary of
how many were successful/unsuccessful.


@subsection Summary

To summarise, when adding a test program to v?l you need to

@enumerate
@item Ensure v?l_test.* exists (if not, create one)
@item Create a test function in @file{tests/test_classname_io.cxx}
@item Add a call to the function in @file{tests/test_v?l_io.cxx}
@end enumerate


@section Credits

Your principle designers for this chapter have been Tim Cootes and Ian Scott.
We based the first draft on the design of the Binary IO system in RADIAL, which was
originally designed in Manchester by Dave Bailes and Dave Cooper.

Finally, the hard work of programming @code{vsl} and the vxl/io libraries was performed by the
C++ user's group at the Dept. of Imaging Science; Danny Allen, Tim Cootes, Nick Costen,
Ian Scott, Christine Beeston, David Cristinacce, Franck Bettinger, Louise Butcher, and
John Kang.
